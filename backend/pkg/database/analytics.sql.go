// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: analytics.sql

package database

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const getAssistantsCountForFlow = `-- name: GetAssistantsCountForFlow :one
SELECT COALESCE(COUNT(id), 0)::bigint AS total_assistants_count
FROM assistants
WHERE flow_id = $1 AND deleted_at IS NULL
`

// Get total count of assistants for a specific flow
func (q *Queries) GetAssistantsCountForFlow(ctx context.Context, flowID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAssistantsCountForFlow, flowID)
	var total_assistants_count int64
	err := row.Scan(&total_assistants_count)
	return total_assistants_count, err
}

const getFlowsForPeriodLast3Months = `-- name: GetFlowsForPeriodLast3Months :many
SELECT id, title
FROM flows
WHERE created_at >= NOW() - INTERVAL '90 days' AND deleted_at IS NULL AND user_id = $1
ORDER BY created_at DESC
`

type GetFlowsForPeriodLast3MonthsRow struct {
	ID    int64  `json:"id"`
	Title string `json:"title"`
}

// Get flow IDs created in the last 3 months for analytics
func (q *Queries) GetFlowsForPeriodLast3Months(ctx context.Context, userID int64) ([]GetFlowsForPeriodLast3MonthsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFlowsForPeriodLast3Months, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFlowsForPeriodLast3MonthsRow
	for rows.Next() {
		var i GetFlowsForPeriodLast3MonthsRow
		if err := rows.Scan(&i.ID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowsForPeriodLastMonth = `-- name: GetFlowsForPeriodLastMonth :many
SELECT id, title
FROM flows
WHERE created_at >= NOW() - INTERVAL '30 days' AND deleted_at IS NULL AND user_id = $1
ORDER BY created_at DESC
`

type GetFlowsForPeriodLastMonthRow struct {
	ID    int64  `json:"id"`
	Title string `json:"title"`
}

// Get flow IDs created in the last month for analytics
func (q *Queries) GetFlowsForPeriodLastMonth(ctx context.Context, userID int64) ([]GetFlowsForPeriodLastMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getFlowsForPeriodLastMonth, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFlowsForPeriodLastMonthRow
	for rows.Next() {
		var i GetFlowsForPeriodLastMonthRow
		if err := rows.Scan(&i.ID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowsForPeriodLastWeek = `-- name: GetFlowsForPeriodLastWeek :many
SELECT id, title
FROM flows
WHERE created_at >= NOW() - INTERVAL '7 days' AND deleted_at IS NULL AND user_id = $1
ORDER BY created_at DESC
`

type GetFlowsForPeriodLastWeekRow struct {
	ID    int64  `json:"id"`
	Title string `json:"title"`
}

// Get flow IDs created in the last week for analytics
func (q *Queries) GetFlowsForPeriodLastWeek(ctx context.Context, userID int64) ([]GetFlowsForPeriodLastWeekRow, error) {
	rows, err := q.db.QueryContext(ctx, getFlowsForPeriodLastWeek, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFlowsForPeriodLastWeekRow
	for rows.Next() {
		var i GetFlowsForPeriodLastWeekRow
		if err := rows.Scan(&i.ID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMsgchainsForFlow = `-- name: GetMsgchainsForFlow :many
SELECT id, type, flow_id, task_id, subtask_id, duration_seconds, created_at, updated_at
FROM msgchains
WHERE flow_id = $1
ORDER BY created_at ASC
`

type GetMsgchainsForFlowRow struct {
	ID              int64         `json:"id"`
	Type            MsgchainType  `json:"type"`
	FlowID          int64         `json:"flow_id"`
	TaskID          sql.NullInt64 `json:"task_id"`
	SubtaskID       sql.NullInt64 `json:"subtask_id"`
	DurationSeconds float64       `json:"duration_seconds"`
	CreatedAt       sql.NullTime  `json:"created_at"`
	UpdatedAt       sql.NullTime  `json:"updated_at"`
}

// Get all msgchains for a flow (including task and subtask level)
func (q *Queries) GetMsgchainsForFlow(ctx context.Context, flowID int64) ([]GetMsgchainsForFlowRow, error) {
	rows, err := q.db.QueryContext(ctx, getMsgchainsForFlow, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMsgchainsForFlowRow
	for rows.Next() {
		var i GetMsgchainsForFlowRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.FlowID,
			&i.TaskID,
			&i.SubtaskID,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubtasksForTasks = `-- name: GetSubtasksForTasks :many
SELECT id, task_id, title, status, created_at, updated_at
FROM subtasks
WHERE task_id = ANY($1::BIGINT[])
ORDER BY id ASC
`

type GetSubtasksForTasksRow struct {
	ID        int64         `json:"id"`
	TaskID    int64         `json:"task_id"`
	Title     string        `json:"title"`
	Status    SubtaskStatus `json:"status"`
	CreatedAt sql.NullTime  `json:"created_at"`
	UpdatedAt sql.NullTime  `json:"updated_at"`
}

// Get all subtasks for multiple tasks
func (q *Queries) GetSubtasksForTasks(ctx context.Context, taskIds []int64) ([]GetSubtasksForTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubtasksForTasks, pq.Array(taskIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubtasksForTasksRow
	for rows.Next() {
		var i GetSubtasksForTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Title,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksForFlow = `-- name: GetTasksForFlow :many
SELECT id, title, created_at, updated_at
FROM tasks
WHERE flow_id = $1
ORDER BY id ASC
`

type GetTasksForFlowRow struct {
	ID        int64        `json:"id"`
	Title     string       `json:"title"`
	CreatedAt sql.NullTime `json:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at"`
}

// Get all tasks for a flow
func (q *Queries) GetTasksForFlow(ctx context.Context, flowID int64) ([]GetTasksForFlowRow, error) {
	rows, err := q.db.QueryContext(ctx, getTasksForFlow, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTasksForFlowRow
	for rows.Next() {
		var i GetTasksForFlowRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToolcallsForFlow = `-- name: GetToolcallsForFlow :many
SELECT tc.id, tc.status, tc.flow_id, tc.task_id, tc.subtask_id, tc.duration_seconds, tc.created_at, tc.updated_at
FROM toolcalls tc
LEFT JOIN tasks t ON tc.task_id = t.id
LEFT JOIN subtasks s ON tc.subtask_id = s.id
INNER JOIN flows f ON tc.flow_id = f.id
WHERE tc.flow_id = $1 AND f.deleted_at IS NULL
  AND (tc.task_id IS NULL OR t.id IS NOT NULL)
  AND (tc.subtask_id IS NULL OR s.id IS NOT NULL)
ORDER BY tc.created_at ASC
`

type GetToolcallsForFlowRow struct {
	ID              int64          `json:"id"`
	Status          ToolcallStatus `json:"status"`
	FlowID          int64          `json:"flow_id"`
	TaskID          sql.NullInt64  `json:"task_id"`
	SubtaskID       sql.NullInt64  `json:"subtask_id"`
	DurationSeconds float64        `json:"duration_seconds"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
}

// Get all toolcalls for a flow
func (q *Queries) GetToolcallsForFlow(ctx context.Context, flowID int64) ([]GetToolcallsForFlowRow, error) {
	rows, err := q.db.QueryContext(ctx, getToolcallsForFlow, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetToolcallsForFlowRow
	for rows.Next() {
		var i GetToolcallsForFlowRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.FlowID,
			&i.TaskID,
			&i.SubtaskID,
			&i.DurationSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
