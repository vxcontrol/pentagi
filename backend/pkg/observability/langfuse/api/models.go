// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "pentagi/pkg/observability/langfuse/api/internal"
	time "time"
)

var (
	createModelRequestFieldModelName       = big.NewInt(1 << 0)
	createModelRequestFieldMatchPattern    = big.NewInt(1 << 1)
	createModelRequestFieldStartDate       = big.NewInt(1 << 2)
	createModelRequestFieldUnit            = big.NewInt(1 << 3)
	createModelRequestFieldInputPrice      = big.NewInt(1 << 4)
	createModelRequestFieldOutputPrice     = big.NewInt(1 << 5)
	createModelRequestFieldTotalPrice      = big.NewInt(1 << 6)
	createModelRequestFieldPricingTiers    = big.NewInt(1 << 7)
	createModelRequestFieldTokenizerID     = big.NewInt(1 << 8)
	createModelRequestFieldTokenizerConfig = big.NewInt(1 << 9)
)

type CreateModelRequest struct {
	// Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime<observation.startTime
	ModelName string `json:"modelName" url:"-"`
	// Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use `(?i)^modelname$`
	MatchPattern string `json:"matchPattern" url:"-"`
	// Apply only to generations which are newer than this ISO date.
	StartDate *time.Time `json:"startDate,omitempty" url:"-"`
	// Unit used by this model.
	Unit *ModelUsageUnit `json:"unit,omitempty" url:"-"`
	// Deprecated. Use 'pricingTiers' instead. Price (USD) per input unit. Creates a default tier if pricingTiers not provided.
	InputPrice *float64 `json:"inputPrice,omitempty" url:"-"`
	// Deprecated. Use 'pricingTiers' instead. Price (USD) per output unit. Creates a default tier if pricingTiers not provided.
	OutputPrice *float64 `json:"outputPrice,omitempty" url:"-"`
	// Deprecated. Use 'pricingTiers' instead. Price (USD) per total units. Cannot be set if input or output price is set. Creates a default tier if pricingTiers not provided.
	TotalPrice *float64 `json:"totalPrice,omitempty" url:"-"`
	// Optional. Array of pricing tiers for this model.
	//
	// Use pricing tiers for all models - both those with threshold-based pricing variations and those with simple flat pricing:
	//
	//   - For models with standard flat pricing: Create a single default tier with your prices
	//     (e.g., one tier with isDefault=true, priority=0, conditions=[], and your standard prices)
	//
	//   - For models with threshold-based pricing: Create a default tier plus additional conditional tiers
	//     (e.g., default tier for standard usage + high-volume tier for usage above certain thresholds)
	//
	// Requirements:
	// - Cannot be provided with flat prices (inputPrice/outputPrice/totalPrice) - use one approach or the other
	// - Must include exactly one default tier with isDefault=true, priority=0, and conditions=[]
	// - All tier names and priorities must be unique within the model
	// - Each tier must define at least one price
	//
	// If omitted, you must provide flat prices instead (inputPrice/outputPrice/totalPrice),
	// which will automatically create a single default tier named "Standard".
	PricingTiers []*PricingTierInput `json:"pricingTiers,omitempty" url:"-"`
	// Optional. Tokenizer to be applied to observations which match to this model. See docs for more details.
	TokenizerID *string `json:"tokenizerId,omitempty" url:"-"`
	// Optional. Configuration for the selected tokenizer. Needs to be JSON. See docs for more details.
	TokenizerConfig interface{} `json:"tokenizerConfig,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CreateModelRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetModelName sets the ModelName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateModelRequest) SetModelName(modelName string) {
	c.ModelName = modelName
	c.require(createModelRequestFieldModelName)
}

// SetMatchPattern sets the MatchPattern field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateModelRequest) SetMatchPattern(matchPattern string) {
	c.MatchPattern = matchPattern
	c.require(createModelRequestFieldMatchPattern)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateModelRequest) SetStartDate(startDate *time.Time) {
	c.StartDate = startDate
	c.require(createModelRequestFieldStartDate)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateModelRequest) SetUnit(unit *ModelUsageUnit) {
	c.Unit = unit
	c.require(createModelRequestFieldUnit)
}

// SetInputPrice sets the InputPrice field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateModelRequest) SetInputPrice(inputPrice *float64) {
	c.InputPrice = inputPrice
	c.require(createModelRequestFieldInputPrice)
}

// SetOutputPrice sets the OutputPrice field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateModelRequest) SetOutputPrice(outputPrice *float64) {
	c.OutputPrice = outputPrice
	c.require(createModelRequestFieldOutputPrice)
}

// SetTotalPrice sets the TotalPrice field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateModelRequest) SetTotalPrice(totalPrice *float64) {
	c.TotalPrice = totalPrice
	c.require(createModelRequestFieldTotalPrice)
}

// SetPricingTiers sets the PricingTiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateModelRequest) SetPricingTiers(pricingTiers []*PricingTierInput) {
	c.PricingTiers = pricingTiers
	c.require(createModelRequestFieldPricingTiers)
}

// SetTokenizerID sets the TokenizerID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateModelRequest) SetTokenizerID(tokenizerID *string) {
	c.TokenizerID = tokenizerID
	c.require(createModelRequestFieldTokenizerID)
}

// SetTokenizerConfig sets the TokenizerConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateModelRequest) SetTokenizerConfig(tokenizerConfig interface{}) {
	c.TokenizerConfig = tokenizerConfig
	c.require(createModelRequestFieldTokenizerConfig)
}

func (c *CreateModelRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateModelRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*c = CreateModelRequest(body)
	return nil
}

func (c *CreateModelRequest) MarshalJSON() ([]byte, error) {
	type embed CreateModelRequest
	var marshaler = struct {
		embed
		StartDate *internal.DateTime `json:"startDate,omitempty"`
	}{
		embed:     embed(*c),
		StartDate: internal.NewOptionalDateTime(c.StartDate),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

var (
	modelsDeleteRequestFieldID = big.NewInt(1 << 0)
)

type ModelsDeleteRequest struct {
	ID string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (m *ModelsDeleteRequest) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *ModelsDeleteRequest) SetID(id string) {
	m.ID = id
	m.require(modelsDeleteRequestFieldID)
}

var (
	modelsGetRequestFieldID = big.NewInt(1 << 0)
)

type ModelsGetRequest struct {
	ID string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (m *ModelsGetRequest) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *ModelsGetRequest) SetID(id string) {
	m.ID = id
	m.require(modelsGetRequestFieldID)
}

var (
	modelsListRequestFieldPage  = big.NewInt(1 << 0)
	modelsListRequestFieldLimit = big.NewInt(1 << 1)
)

type ModelsListRequest struct {
	// page number, starts at 1
	Page *int `json:"-" url:"page,omitempty"`
	// limit of items per page
	Limit *int `json:"-" url:"limit,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (m *ModelsListRequest) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *ModelsListRequest) SetPage(page *int) {
	m.Page = page
	m.require(modelsListRequestFieldPage)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *ModelsListRequest) SetLimit(limit *int) {
	m.Limit = limit
	m.require(modelsListRequestFieldLimit)
}

// Model definition used for transforming usage into USD cost and/or tokenization.
//
// Models can have either simple flat pricing or tiered pricing:
// - Flat pricing: Single price per usage type (legacy, but still supported)
// - Tiered pricing: Multiple pricing tiers with conditional matching based on usage patterns
//
// The pricing tiers approach is recommended for models with usage-based pricing variations.
// When using tiered pricing, the flat price fields (inputPrice, outputPrice, prices) are populated
// from the default tier for backward compatibility.
var (
	modelFieldID                = big.NewInt(1 << 0)
	modelFieldModelName         = big.NewInt(1 << 1)
	modelFieldMatchPattern      = big.NewInt(1 << 2)
	modelFieldStartDate         = big.NewInt(1 << 3)
	modelFieldUnit              = big.NewInt(1 << 4)
	modelFieldInputPrice        = big.NewInt(1 << 5)
	modelFieldOutputPrice       = big.NewInt(1 << 6)
	modelFieldTotalPrice        = big.NewInt(1 << 7)
	modelFieldTokenizerID       = big.NewInt(1 << 8)
	modelFieldTokenizerConfig   = big.NewInt(1 << 9)
	modelFieldIsLangfuseManaged = big.NewInt(1 << 10)
	modelFieldCreatedAt         = big.NewInt(1 << 11)
	modelFieldPrices            = big.NewInt(1 << 12)
	modelFieldPricingTiers      = big.NewInt(1 << 13)
)

type Model struct {
	ID string `json:"id" url:"id"`
	// Name of the model definition. If multiple with the same name exist, they are applied in the following order: (1) custom over built-in, (2) newest according to startTime where model.startTime<observation.startTime
	ModelName string `json:"modelName" url:"modelName"`
	// Regex pattern which matches this model definition to generation.model. Useful in case of fine-tuned models. If you want to exact match, use `(?i)^modelname$`
	MatchPattern string `json:"matchPattern" url:"matchPattern"`
	// Apply only to generations which are newer than this ISO date.
	StartDate *time.Time `json:"startDate,omitempty" url:"startDate,omitempty"`
	// Unit used by this model.
	Unit *ModelUsageUnit `json:"unit,omitempty" url:"unit,omitempty"`
	// Deprecated. See 'prices' instead. Price (USD) per input unit
	InputPrice *float64 `json:"inputPrice,omitempty" url:"inputPrice,omitempty"`
	// Deprecated. See 'prices' instead. Price (USD) per output unit
	OutputPrice *float64 `json:"outputPrice,omitempty" url:"outputPrice,omitempty"`
	// Deprecated. See 'prices' instead. Price (USD) per total unit. Cannot be set if input or output price is set.
	TotalPrice *float64 `json:"totalPrice,omitempty" url:"totalPrice,omitempty"`
	// Optional. Tokenizer to be applied to observations which match to this model. See docs for more details.
	TokenizerID       *string     `json:"tokenizerId,omitempty" url:"tokenizerId,omitempty"`
	TokenizerConfig   interface{} `json:"tokenizerConfig" url:"tokenizerConfig"`
	IsLangfuseManaged bool        `json:"isLangfuseManaged" url:"isLangfuseManaged"`
	// Timestamp when the model was created
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Deprecated. Use 'pricingTiers' instead for models with usage-based pricing variations.
	//
	// This field shows prices by usage type from the default pricing tier. Maintained for backward compatibility.
	// If the model uses tiered pricing, this field will be populated from the default tier's prices.
	Prices map[string]*ModelPrice `json:"prices" url:"prices"`
	// Array of pricing tiers with conditional pricing based on usage thresholds.
	//
	// Pricing tiers enable accurate cost tracking for models that charge different rates based on usage patterns
	// (e.g., different rates for high-volume usage, large context windows, or cached tokens).
	//
	// Each model must have exactly one default tier (isDefault=true, priority=0) that serves as a fallback.
	// Additional conditional tiers can be defined with specific matching criteria.
	//
	// If this array is empty, the model uses legacy flat pricing from the inputPrice/outputPrice/totalPrice fields.
	PricingTiers []*PricingTier `json:"pricingTiers" url:"pricingTiers"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Model) GetID() string {
	if m == nil {
		return ""
	}
	return m.ID
}

func (m *Model) GetModelName() string {
	if m == nil {
		return ""
	}
	return m.ModelName
}

func (m *Model) GetMatchPattern() string {
	if m == nil {
		return ""
	}
	return m.MatchPattern
}

func (m *Model) GetStartDate() *time.Time {
	if m == nil {
		return nil
	}
	return m.StartDate
}

func (m *Model) GetUnit() *ModelUsageUnit {
	if m == nil {
		return nil
	}
	return m.Unit
}

func (m *Model) GetInputPrice() *float64 {
	if m == nil {
		return nil
	}
	return m.InputPrice
}

func (m *Model) GetOutputPrice() *float64 {
	if m == nil {
		return nil
	}
	return m.OutputPrice
}

func (m *Model) GetTotalPrice() *float64 {
	if m == nil {
		return nil
	}
	return m.TotalPrice
}

func (m *Model) GetTokenizerID() *string {
	if m == nil {
		return nil
	}
	return m.TokenizerID
}

func (m *Model) GetTokenizerConfig() interface{} {
	if m == nil {
		return nil
	}
	return m.TokenizerConfig
}

func (m *Model) GetIsLangfuseManaged() bool {
	if m == nil {
		return false
	}
	return m.IsLangfuseManaged
}

func (m *Model) GetCreatedAt() time.Time {
	if m == nil {
		return time.Time{}
	}
	return m.CreatedAt
}

func (m *Model) GetPrices() map[string]*ModelPrice {
	if m == nil {
		return nil
	}
	return m.Prices
}

func (m *Model) GetPricingTiers() []*PricingTier {
	if m == nil {
		return nil
	}
	return m.PricingTiers
}

func (m *Model) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Model) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetID(id string) {
	m.ID = id
	m.require(modelFieldID)
}

// SetModelName sets the ModelName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetModelName(modelName string) {
	m.ModelName = modelName
	m.require(modelFieldModelName)
}

// SetMatchPattern sets the MatchPattern field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetMatchPattern(matchPattern string) {
	m.MatchPattern = matchPattern
	m.require(modelFieldMatchPattern)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetStartDate(startDate *time.Time) {
	m.StartDate = startDate
	m.require(modelFieldStartDate)
}

// SetUnit sets the Unit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetUnit(unit *ModelUsageUnit) {
	m.Unit = unit
	m.require(modelFieldUnit)
}

// SetInputPrice sets the InputPrice field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetInputPrice(inputPrice *float64) {
	m.InputPrice = inputPrice
	m.require(modelFieldInputPrice)
}

// SetOutputPrice sets the OutputPrice field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetOutputPrice(outputPrice *float64) {
	m.OutputPrice = outputPrice
	m.require(modelFieldOutputPrice)
}

// SetTotalPrice sets the TotalPrice field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetTotalPrice(totalPrice *float64) {
	m.TotalPrice = totalPrice
	m.require(modelFieldTotalPrice)
}

// SetTokenizerID sets the TokenizerID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetTokenizerID(tokenizerID *string) {
	m.TokenizerID = tokenizerID
	m.require(modelFieldTokenizerID)
}

// SetTokenizerConfig sets the TokenizerConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetTokenizerConfig(tokenizerConfig interface{}) {
	m.TokenizerConfig = tokenizerConfig
	m.require(modelFieldTokenizerConfig)
}

// SetIsLangfuseManaged sets the IsLangfuseManaged field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetIsLangfuseManaged(isLangfuseManaged bool) {
	m.IsLangfuseManaged = isLangfuseManaged
	m.require(modelFieldIsLangfuseManaged)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetCreatedAt(createdAt time.Time) {
	m.CreatedAt = createdAt
	m.require(modelFieldCreatedAt)
}

// SetPrices sets the Prices field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetPrices(prices map[string]*ModelPrice) {
	m.Prices = prices
	m.require(modelFieldPrices)
}

// SetPricingTiers sets the PricingTiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *Model) SetPricingTiers(pricingTiers []*PricingTier) {
	m.PricingTiers = pricingTiers
	m.require(modelFieldPricingTiers)
}

func (m *Model) UnmarshalJSON(data []byte) error {
	type embed Model
	var unmarshaler = struct {
		embed
		StartDate *internal.DateTime `json:"startDate,omitempty"`
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = Model(unmarshaler.embed)
	m.StartDate = unmarshaler.StartDate.TimePtr()
	m.CreatedAt = unmarshaler.CreatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Model) MarshalJSON() ([]byte, error) {
	type embed Model
	var marshaler = struct {
		embed
		StartDate *internal.DateTime `json:"startDate,omitempty"`
		CreatedAt *internal.DateTime `json:"createdAt"`
	}{
		embed:     embed(*m),
		StartDate: internal.NewOptionalDateTime(m.StartDate),
		CreatedAt: internal.NewDateTime(m.CreatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *Model) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	modelPriceFieldPrice = big.NewInt(1 << 0)
)

type ModelPrice struct {
	Price float64 `json:"price" url:"price"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelPrice) GetPrice() float64 {
	if m == nil {
		return 0
	}
	return m.Price
}

func (m *ModelPrice) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelPrice) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetPrice sets the Price field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *ModelPrice) SetPrice(price float64) {
	m.Price = price
	m.require(modelPriceFieldPrice)
}

func (m *ModelPrice) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelPrice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelPrice(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelPrice) MarshalJSON() ([]byte, error) {
	type embed ModelPrice
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *ModelPrice) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Unit of usage in Langfuse
type ModelUsageUnit string

const (
	ModelUsageUnitCharacters   ModelUsageUnit = "CHARACTERS"
	ModelUsageUnitTokens       ModelUsageUnit = "TOKENS"
	ModelUsageUnitMilliseconds ModelUsageUnit = "MILLISECONDS"
	ModelUsageUnitSeconds      ModelUsageUnit = "SECONDS"
	ModelUsageUnitImages       ModelUsageUnit = "IMAGES"
	ModelUsageUnitRequests     ModelUsageUnit = "REQUESTS"
)

func NewModelUsageUnitFromString(s string) (ModelUsageUnit, error) {
	switch s {
	case "CHARACTERS":
		return ModelUsageUnitCharacters, nil
	case "TOKENS":
		return ModelUsageUnitTokens, nil
	case "MILLISECONDS":
		return ModelUsageUnitMilliseconds, nil
	case "SECONDS":
		return ModelUsageUnitSeconds, nil
	case "IMAGES":
		return ModelUsageUnitImages, nil
	case "REQUESTS":
		return ModelUsageUnitRequests, nil
	}
	var t ModelUsageUnit
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ModelUsageUnit) Ptr() *ModelUsageUnit {
	return &m
}

var (
	paginatedModelsFieldData = big.NewInt(1 << 0)
	paginatedModelsFieldMeta = big.NewInt(1 << 1)
)

type PaginatedModels struct {
	Data []*Model           `json:"data" url:"data"`
	Meta *UtilsMetaResponse `json:"meta" url:"meta"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedModels) GetData() []*Model {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaginatedModels) GetMeta() *UtilsMetaResponse {
	if p == nil {
		return nil
	}
	return p.Meta
}

func (p *PaginatedModels) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedModels) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedModels) SetData(data []*Model) {
	p.Data = data
	p.require(paginatedModelsFieldData)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedModels) SetMeta(meta *UtilsMetaResponse) {
	p.Meta = meta
	p.require(paginatedModelsFieldMeta)
}

func (p *PaginatedModels) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedModels
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedModels(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedModels) MarshalJSON() ([]byte, error) {
	type embed PaginatedModels
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedModels) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Pricing tier definition with conditional pricing based on usage thresholds.
//
// Pricing tiers enable accurate cost tracking for LLM providers that charge different rates based on usage patterns.
// For example, some providers charge higher rates when context size exceeds certain thresholds.
//
// How tier matching works:
// 1. Tiers are evaluated in ascending priority order (priority 1 before priority 2, etc.)
// 2. The first tier where ALL conditions match is selected
// 3. If no conditional tiers match, the default tier is used as a fallback
// 4. The default tier has priority 0 and no conditions
//
// Why priorities matter:
// - Lower priority numbers are evaluated first, allowing you to define specific cases before general ones
// - Example: Priority 1 for "high usage" (>200K tokens), Priority 2 for "medium usage" (>100K tokens), Priority 0 for default
// - Without proper ordering, a less specific condition might match before a more specific one
//
// Every model must have exactly one default tier to ensure cost calculation always succeeds.
var (
	pricingTierFieldID         = big.NewInt(1 << 0)
	pricingTierFieldName       = big.NewInt(1 << 1)
	pricingTierFieldIsDefault  = big.NewInt(1 << 2)
	pricingTierFieldPriority   = big.NewInt(1 << 3)
	pricingTierFieldConditions = big.NewInt(1 << 4)
	pricingTierFieldPrices     = big.NewInt(1 << 5)
)

type PricingTier struct {
	// Unique identifier for the pricing tier
	ID string `json:"id" url:"id"`
	// Name of the pricing tier for display and identification purposes.
	//
	// Examples: "Standard", "High Volume Tier", "Large Context", "Extended Context Tier"
	Name string `json:"name" url:"name"`
	// Whether this is the default tier. Every model must have exactly one default tier with priority 0 and no conditions.
	//
	// The default tier serves as a fallback when no conditional tiers match, ensuring cost calculation always succeeds.
	// It typically represents the base pricing for standard usage patterns.
	IsDefault bool `json:"isDefault" url:"isDefault"`
	// Priority for tier matching evaluation. Lower numbers = higher priority (evaluated first).
	//
	// The default tier must always have priority 0. Conditional tiers should have priority 1, 2, 3, etc.
	//
	// Example ordering:
	// - Priority 0: Default tier (no conditions, always matches as fallback)
	// - Priority 1: High usage tier (e.g., >200K tokens)
	// - Priority 2: Medium usage tier (e.g., >100K tokens)
	//
	// This ensures more specific conditions are checked before general ones.
	Priority int `json:"priority" url:"priority"`
	// Array of conditions that must ALL be met for this tier to match (AND logic).
	//
	// The default tier must have an empty conditions array. Conditional tiers should have one or more conditions
	// that define when this tier's pricing applies.
	//
	// Multiple conditions enable complex matching scenarios (e.g., "high input tokens AND low output tokens").
	Conditions []*PricingTierCondition `json:"conditions" url:"conditions"`
	// Prices (USD) by usage type for this tier.
	//
	// Common usage types: "input", "output", "total", "request", "image"
	// Prices are specified in USD per unit (e.g., per token, per request, per second).
	//
	// Example: {"input": 0.000003, "output": 0.000015} means $3 per million input tokens and $15 per million output tokens.
	Prices map[string]float64 `json:"prices" url:"prices"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PricingTier) GetID() string {
	if p == nil {
		return ""
	}
	return p.ID
}

func (p *PricingTier) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PricingTier) GetIsDefault() bool {
	if p == nil {
		return false
	}
	return p.IsDefault
}

func (p *PricingTier) GetPriority() int {
	if p == nil {
		return 0
	}
	return p.Priority
}

func (p *PricingTier) GetConditions() []*PricingTierCondition {
	if p == nil {
		return nil
	}
	return p.Conditions
}

func (p *PricingTier) GetPrices() map[string]float64 {
	if p == nil {
		return nil
	}
	return p.Prices
}

func (p *PricingTier) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PricingTier) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTier) SetID(id string) {
	p.ID = id
	p.require(pricingTierFieldID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTier) SetName(name string) {
	p.Name = name
	p.require(pricingTierFieldName)
}

// SetIsDefault sets the IsDefault field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTier) SetIsDefault(isDefault bool) {
	p.IsDefault = isDefault
	p.require(pricingTierFieldIsDefault)
}

// SetPriority sets the Priority field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTier) SetPriority(priority int) {
	p.Priority = priority
	p.require(pricingTierFieldPriority)
}

// SetConditions sets the Conditions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTier) SetConditions(conditions []*PricingTierCondition) {
	p.Conditions = conditions
	p.require(pricingTierFieldConditions)
}

// SetPrices sets the Prices field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTier) SetPrices(prices map[string]float64) {
	p.Prices = prices
	p.require(pricingTierFieldPrices)
}

func (p *PricingTier) UnmarshalJSON(data []byte) error {
	type unmarshaler PricingTier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PricingTier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PricingTier) MarshalJSON() ([]byte, error) {
	type embed PricingTier
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PricingTier) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Condition for matching a pricing tier based on usage details. Used to implement tiered pricing models where costs vary based on usage thresholds.
//
// How it works:
// 1. The regex pattern matches against usage detail keys (e.g., "input_tokens", "input_cached")
// 2. Values of all matching keys are summed together
// 3. The sum is compared against the threshold value using the specified operator
// 4. All conditions in a tier must be met (AND logic) for the tier to match
//
// Common use cases:
// - Threshold-based pricing: Match when accumulated usage exceeds a certain amount
// - Usage-type-specific pricing: Different rates for cached vs non-cached tokens, or input vs output
// - Volume-based pricing: Different rates based on total request or token count
var (
	pricingTierConditionFieldUsageDetailPattern = big.NewInt(1 << 0)
	pricingTierConditionFieldOperator           = big.NewInt(1 << 1)
	pricingTierConditionFieldValue              = big.NewInt(1 << 2)
	pricingTierConditionFieldCaseSensitive      = big.NewInt(1 << 3)
)

type PricingTierCondition struct {
	// Regex pattern to match against usage detail keys. All matching keys' values are summed for threshold comparison.
	//
	// Examples:
	// - "^input" matches "input", "input_tokens", "input_cached", etc.
	// - "^(input|prompt)" matches both "input_tokens" and "prompt_tokens"
	// - "_cache$" matches "input_cache", "output_cache", etc.
	//
	// The pattern is case-insensitive by default. If no keys match, the sum is treated as zero.
	UsageDetailPattern string `json:"usageDetailPattern" url:"usageDetailPattern"`
	// Comparison operator to apply between the summed value and the threshold.
	//
	// - gt: greater than (sum > threshold)
	// - gte: greater than or equal (sum >= threshold)
	// - lt: less than (sum < threshold)
	// - lte: less than or equal (sum <= threshold)
	// - eq: equal (sum == threshold)
	// - neq: not equal (sum != threshold)
	Operator PricingTierOperator `json:"operator" url:"operator"`
	// Threshold value for comparison. For token-based pricing, this is typically the token count threshold (e.g., 200000 for a 200K token threshold).
	Value float64 `json:"value" url:"value"`
	// Whether the regex pattern matching is case-sensitive. Default is false (case-insensitive matching).
	CaseSensitive bool `json:"caseSensitive" url:"caseSensitive"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PricingTierCondition) GetUsageDetailPattern() string {
	if p == nil {
		return ""
	}
	return p.UsageDetailPattern
}

func (p *PricingTierCondition) GetOperator() PricingTierOperator {
	if p == nil {
		return ""
	}
	return p.Operator
}

func (p *PricingTierCondition) GetValue() float64 {
	if p == nil {
		return 0
	}
	return p.Value
}

func (p *PricingTierCondition) GetCaseSensitive() bool {
	if p == nil {
		return false
	}
	return p.CaseSensitive
}

func (p *PricingTierCondition) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PricingTierCondition) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetUsageDetailPattern sets the UsageDetailPattern field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTierCondition) SetUsageDetailPattern(usageDetailPattern string) {
	p.UsageDetailPattern = usageDetailPattern
	p.require(pricingTierConditionFieldUsageDetailPattern)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTierCondition) SetOperator(operator PricingTierOperator) {
	p.Operator = operator
	p.require(pricingTierConditionFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTierCondition) SetValue(value float64) {
	p.Value = value
	p.require(pricingTierConditionFieldValue)
}

// SetCaseSensitive sets the CaseSensitive field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTierCondition) SetCaseSensitive(caseSensitive bool) {
	p.CaseSensitive = caseSensitive
	p.require(pricingTierConditionFieldCaseSensitive)
}

func (p *PricingTierCondition) UnmarshalJSON(data []byte) error {
	type unmarshaler PricingTierCondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PricingTierCondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PricingTierCondition) MarshalJSON() ([]byte, error) {
	type embed PricingTierCondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PricingTierCondition) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Input schema for creating a pricing tier. The tier ID will be automatically generated server-side.
//
// When creating a model with pricing tiers:
// - Exactly one tier must have isDefault=true (the fallback tier)
// - The default tier must have priority=0 and conditions=[]
// - All tier names and priorities must be unique within the model
// - Each tier must define at least one price
//
// See PricingTier for detailed information about how tiers work and why they're useful.
var (
	pricingTierInputFieldName       = big.NewInt(1 << 0)
	pricingTierInputFieldIsDefault  = big.NewInt(1 << 1)
	pricingTierInputFieldPriority   = big.NewInt(1 << 2)
	pricingTierInputFieldConditions = big.NewInt(1 << 3)
	pricingTierInputFieldPrices     = big.NewInt(1 << 4)
)

type PricingTierInput struct {
	// Name of the pricing tier for display and identification purposes.
	//
	// Must be unique within the model. Common patterns: "Standard", "High Volume Tier", "Extended Context"
	Name string `json:"name" url:"name"`
	// Whether this is the default tier. Exactly one tier per model must be marked as default.
	//
	// Requirements for default tier:
	// - Must have isDefault=true
	// - Must have priority=0
	// - Must have empty conditions array (conditions=[])
	//
	// The default tier acts as a fallback when no conditional tiers match.
	IsDefault bool `json:"isDefault" url:"isDefault"`
	// Priority for tier matching evaluation. Lower numbers = higher priority (evaluated first).
	//
	// Must be unique within the model. The default tier must have priority=0.
	// Conditional tiers should use priority 1, 2, 3, etc. based on their specificity.
	Priority int `json:"priority" url:"priority"`
	// Array of conditions that must ALL be met for this tier to match (AND logic).
	//
	// The default tier must have an empty array (conditions=[]).
	// Conditional tiers should define one or more conditions that specify when this tier's pricing applies.
	//
	// Each condition specifies a regex pattern, operator, and threshold value for matching against usage details.
	Conditions []*PricingTierCondition `json:"conditions" url:"conditions"`
	// Prices (USD) by usage type for this tier. At least one price must be defined.
	//
	// Common usage types: "input", "output", "total", "request", "image"
	// Prices are in USD per unit (e.g., per token).
	//
	// Example: {"input": 0.000003, "output": 0.000015} represents $3 per million input tokens and $15 per million output tokens.
	Prices map[string]float64 `json:"prices" url:"prices"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PricingTierInput) GetName() string {
	if p == nil {
		return ""
	}
	return p.Name
}

func (p *PricingTierInput) GetIsDefault() bool {
	if p == nil {
		return false
	}
	return p.IsDefault
}

func (p *PricingTierInput) GetPriority() int {
	if p == nil {
		return 0
	}
	return p.Priority
}

func (p *PricingTierInput) GetConditions() []*PricingTierCondition {
	if p == nil {
		return nil
	}
	return p.Conditions
}

func (p *PricingTierInput) GetPrices() map[string]float64 {
	if p == nil {
		return nil
	}
	return p.Prices
}

func (p *PricingTierInput) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PricingTierInput) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTierInput) SetName(name string) {
	p.Name = name
	p.require(pricingTierInputFieldName)
}

// SetIsDefault sets the IsDefault field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTierInput) SetIsDefault(isDefault bool) {
	p.IsDefault = isDefault
	p.require(pricingTierInputFieldIsDefault)
}

// SetPriority sets the Priority field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTierInput) SetPriority(priority int) {
	p.Priority = priority
	p.require(pricingTierInputFieldPriority)
}

// SetConditions sets the Conditions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTierInput) SetConditions(conditions []*PricingTierCondition) {
	p.Conditions = conditions
	p.require(pricingTierInputFieldConditions)
}

// SetPrices sets the Prices field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PricingTierInput) SetPrices(prices map[string]float64) {
	p.Prices = prices
	p.require(pricingTierInputFieldPrices)
}

func (p *PricingTierInput) UnmarshalJSON(data []byte) error {
	type unmarshaler PricingTierInput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PricingTierInput(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PricingTierInput) MarshalJSON() ([]byte, error) {
	type embed PricingTierInput
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PricingTierInput) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Comparison operators for pricing tier conditions
type PricingTierOperator string

const (
	PricingTierOperatorGt  PricingTierOperator = "gt"
	PricingTierOperatorGte PricingTierOperator = "gte"
	PricingTierOperatorLt  PricingTierOperator = "lt"
	PricingTierOperatorLte PricingTierOperator = "lte"
	PricingTierOperatorEq  PricingTierOperator = "eq"
	PricingTierOperatorNeq PricingTierOperator = "neq"
)

func NewPricingTierOperatorFromString(s string) (PricingTierOperator, error) {
	switch s {
	case "gt":
		return PricingTierOperatorGt, nil
	case "gte":
		return PricingTierOperatorGte, nil
	case "lt":
		return PricingTierOperatorLt, nil
	case "lte":
		return PricingTierOperatorLte, nil
	case "eq":
		return PricingTierOperatorEq, nil
	case "neq":
		return PricingTierOperatorNeq, nil
	}
	var t PricingTierOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PricingTierOperator) Ptr() *PricingTierOperator {
	return &p
}
