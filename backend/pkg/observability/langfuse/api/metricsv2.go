// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "pentagi/pkg/observability/langfuse/api/internal"
)

var (
	metricsV2MetricsRequestFieldQuery = big.NewInt(1 << 0)
)

type MetricsV2MetricsRequest struct {
	// JSON string containing the query parameters with the following structure:
	// ```json
	//
	//	{
	//	  "view": string,           // Required. One of "observations", "scores-numeric", "scores-categorical"
	//	  "dimensions": [           // Optional. Default: []
	//	    {
	//	      "field": string       // Field to group by (see available dimensions above)
	//	    }
	//	  ],
	//	  "metrics": [              // Required. At least one metric must be provided
	//	    {
	//	      "measure": string,    // What to measure (see available measures above)
	//	      "aggregation": string // How to aggregate: "sum", "avg", "count", "max", "min", "p50", "p75", "p90", "p95", "p99", "histogram"
	//	    }
	//	  ],
	//	  "filters": [              // Optional. Default: []
	//	    {
	//	      "column": string,     // Column to filter on (any dimension field)
	//	      "operator": string,   // Operator based on type:
	//	                            // - datetime: ">", "<", ">=", "<="
	//	                            // - string: "=", "contains", "does not contain", "starts with", "ends with"
	//	                            // - stringOptions: "any of", "none of"
	//	                            // - arrayOptions: "any of", "none of", "all of"
	//	                            // - number: "=", ">", "<", ">=", "<="
	//	                            // - stringObject/numberObject: same as string/number with required "key"
	//	                            // - boolean: "=", "<>"
	//	                            // - null: "is null", "is not null"
	//	      "value": any,         // Value to compare against
	//	      "type": string,       // Data type: "datetime", "string", "number", "stringOptions", "categoryOptions", "arrayOptions", "stringObject", "numberObject", "boolean", "null"
	//	      "key": string         // Required only for stringObject/numberObject types (e.g., metadata filtering)
	//	    }
	//	  ],
	//	  "timeDimension": {        // Optional. Default: null. If provided, results will be grouped by time
	//	    "granularity": string   // One of "auto", "minute", "hour", "day", "week", "month"
	//	  },
	//	  "fromTimestamp": string,  // Required. ISO datetime string for start of time range
	//	  "toTimestamp": string,    // Required. ISO datetime string for end of time range (must be after fromTimestamp)
	//	  "orderBy": [              // Optional. Default: null
	//	    {
	//	      "field": string,      // Field to order by (dimension or metric alias)
	//	      "direction": string   // "asc" or "desc"
	//	    }
	//	  ],
	//	  "config": {               // Optional. Query-specific configuration
	//	    "bins": number,         // Optional. Number of bins for histogram aggregation (1-100), default: 10
	//	    "row_limit": number     // Optional. Maximum number of rows to return (1-1000), default: 100
	//	  }
	//	}
	//
	// ```
	Query string `json:"-" url:"query"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (m *MetricsV2MetricsRequest) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetQuery sets the Query field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MetricsV2MetricsRequest) SetQuery(query string) {
	m.Query = query
	m.require(metricsV2MetricsRequestFieldQuery)
}

var (
	metricsV2ResponseFieldData = big.NewInt(1 << 0)
)

type MetricsV2Response struct {
	// The metrics data. Each item in the list contains the metric values and dimensions requested in the query.
	// Format varies based on the query parameters.
	// Histograms will return an array with [lower, upper, height] tuples.
	Data []map[string]interface{} `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetricsV2Response) GetData() []map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MetricsV2Response) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetricsV2Response) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MetricsV2Response) SetData(data []map[string]interface{}) {
	m.Data = data
	m.require(metricsV2ResponseFieldData)
}

func (m *MetricsV2Response) UnmarshalJSON(data []byte) error {
	type unmarshaler MetricsV2Response
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetricsV2Response(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetricsV2Response) MarshalJSON() ([]byte, error) {
	type embed MetricsV2Response
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MetricsV2Response) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}
