// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "pentagi/pkg/observability/langfuse/api/internal"
	time "time"
)

var (
	traceDeleteRequestFieldTraceID = big.NewInt(1 << 0)
)

type TraceDeleteRequest struct {
	// The unique langfuse identifier of the trace to delete
	TraceID string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (t *TraceDeleteRequest) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTraceID sets the TraceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceDeleteRequest) SetTraceID(traceID string) {
	t.TraceID = traceID
	t.require(traceDeleteRequestFieldTraceID)
}

var (
	traceDeleteMultipleRequestFieldTraceIDs = big.NewInt(1 << 0)
)

type TraceDeleteMultipleRequest struct {
	// List of trace IDs to delete
	TraceIDs []string `json:"traceIds" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (t *TraceDeleteMultipleRequest) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTraceIDs sets the TraceIDs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceDeleteMultipleRequest) SetTraceIDs(traceIDs []string) {
	t.TraceIDs = traceIDs
	t.require(traceDeleteMultipleRequestFieldTraceIDs)
}

func (t *TraceDeleteMultipleRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler TraceDeleteMultipleRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*t = TraceDeleteMultipleRequest(body)
	return nil
}

func (t *TraceDeleteMultipleRequest) MarshalJSON() ([]byte, error) {
	type embed TraceDeleteMultipleRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

var (
	traceGetRequestFieldTraceID = big.NewInt(1 << 0)
)

type TraceGetRequest struct {
	// The unique langfuse identifier of a trace
	TraceID string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (t *TraceGetRequest) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetTraceID sets the TraceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceGetRequest) SetTraceID(traceID string) {
	t.TraceID = traceID
	t.require(traceGetRequestFieldTraceID)
}

var (
	traceListRequestFieldPage          = big.NewInt(1 << 0)
	traceListRequestFieldLimit         = big.NewInt(1 << 1)
	traceListRequestFieldUserID        = big.NewInt(1 << 2)
	traceListRequestFieldName          = big.NewInt(1 << 3)
	traceListRequestFieldSessionID     = big.NewInt(1 << 4)
	traceListRequestFieldFromTimestamp = big.NewInt(1 << 5)
	traceListRequestFieldToTimestamp   = big.NewInt(1 << 6)
	traceListRequestFieldOrderBy       = big.NewInt(1 << 7)
	traceListRequestFieldTags          = big.NewInt(1 << 8)
	traceListRequestFieldVersion       = big.NewInt(1 << 9)
	traceListRequestFieldRelease       = big.NewInt(1 << 10)
	traceListRequestFieldEnvironment   = big.NewInt(1 << 11)
	traceListRequestFieldFields        = big.NewInt(1 << 12)
	traceListRequestFieldFilter        = big.NewInt(1 << 13)
)

type TraceListRequest struct {
	// Page number, starts at 1
	Page *int `json:"-" url:"page,omitempty"`
	// Limit of items per page. If you encounter api issues due to too large page sizes, try to reduce the limit.
	Limit     *int    `json:"-" url:"limit,omitempty"`
	UserID    *string `json:"-" url:"userId,omitempty"`
	Name      *string `json:"-" url:"name,omitempty"`
	SessionID *string `json:"-" url:"sessionId,omitempty"`
	// Optional filter to only include traces with a trace.timestamp on or after a certain datetime (ISO 8601)
	FromTimestamp *time.Time `json:"-" url:"fromTimestamp,omitempty"`
	// Optional filter to only include traces with a trace.timestamp before a certain datetime (ISO 8601)
	ToTimestamp *time.Time `json:"-" url:"toTimestamp,omitempty"`
	// Format of the string [field].[asc/desc]. Fields: id, timestamp, name, userId, release, version, public, bookmarked, sessionId. Example: timestamp.asc
	OrderBy *string `json:"-" url:"orderBy,omitempty"`
	// Only traces that include all of these tags will be returned.
	Tags []*string `json:"-" url:"tags,omitempty"`
	// Optional filter to only include traces with a certain version.
	Version *string `json:"-" url:"version,omitempty"`
	// Optional filter to only include traces with a certain release.
	Release *string `json:"-" url:"release,omitempty"`
	// Optional filter for traces where the environment is one of the provided values.
	Environment []*string `json:"-" url:"environment,omitempty"`
	// Comma-separated list of fields to include in the response. Available field groups: 'core' (always included), 'io' (input, output, metadata), 'scores', 'observations', 'metrics'. If not specified, all fields are returned. Example: 'core,scores,metrics'. Note: Excluded 'observations' or 'scores' fields return empty arrays; excluded 'metrics' returns -1 for 'totalCost' and 'latency'.
	Fields *string `json:"-" url:"fields,omitempty"`
	// JSON string containing an array of filter conditions. When provided, this takes precedence over query parameter filters (userId, name, sessionId, tags, version, release, environment, fromTimestamp, toTimestamp).
	//
	// ## Filter Structure
	// Each filter condition has the following structure:
	// ```json
	// [
	//
	//	{
	//	  "type": string,           // Required. One of: "datetime", "string", "number", "stringOptions", "categoryOptions", "arrayOptions", "stringObject", "numberObject", "boolean", "null"
	//	  "column": string,         // Required. Column to filter on (see available columns below)
	//	  "operator": string,       // Required. Operator based on type:
	//	                            // - datetime: ">", "<", ">=", "<="
	//	                            // - string: "=", "contains", "does not contain", "starts with", "ends with"
	//	                            // - stringOptions: "any of", "none of"
	//	                            // - categoryOptions: "any of", "none of"
	//	                            // - arrayOptions: "any of", "none of", "all of"
	//	                            // - number: "=", ">", "<", ">=", "<="
	//	                            // - stringObject: "=", "contains", "does not contain", "starts with", "ends with"
	//	                            // - numberObject: "=", ">", "<", ">=", "<="
	//	                            // - boolean: "=", "<>"
	//	                            // - null: "is null", "is not null"
	//	  "value": any,             // Required (except for null type). Value to compare against. Type depends on filter type
	//	  "key": string             // Required only for stringObject, numberObject, and categoryOptions types when filtering on nested fields like metadata
	//	}
	//
	// ]
	// ```
	//
	// ## Available Columns
	//
	// ### Core Trace Fields
	// - `id` (string) - Trace ID
	// - `name` (string) - Trace name
	// - `timestamp` (datetime) - Trace timestamp
	// - `userId` (string) - User ID
	// - `sessionId` (string) - Session ID
	// - `environment` (string) - Environment tag
	// - `version` (string) - Version tag
	// - `release` (string) - Release tag
	// - `tags` (arrayOptions) - Array of tags
	// - `bookmarked` (boolean) - Bookmark status
	//
	// ### Structured Data
	// - `metadata` (stringObject/numberObject/categoryOptions) - Metadata key-value pairs. Use `key` parameter to filter on specific metadata keys.
	//
	// ### Aggregated Metrics (from observations)
	// These metrics are aggregated from all observations within the trace:
	// - `latency` (number) - Latency in seconds (time from first observation start to last observation end)
	// - `inputTokens` (number) - Total input tokens across all observations
	// - `outputTokens` (number) - Total output tokens across all observations
	// - `totalTokens` (number) - Total tokens (alias: `tokens`)
	// - `inputCost` (number) - Total input cost in USD
	// - `outputCost` (number) - Total output cost in USD
	// - `totalCost` (number) - Total cost in USD
	//
	// ### Observation Level Aggregations
	// These fields aggregate observation levels within the trace:
	// - `level` (string) - Highest severity level (ERROR > WARNING > DEFAULT > DEBUG)
	// - `warningCount` (number) - Count of WARNING level observations
	// - `errorCount` (number) - Count of ERROR level observations
	// - `defaultCount` (number) - Count of DEFAULT level observations
	// - `debugCount` (number) - Count of DEBUG level observations
	//
	// ### Scores (requires join with scores table)
	// - `scores_avg` (number) - Average of numeric scores (alias: `scores`)
	// - `score_categories` (categoryOptions) - Categorical score values
	//
	// ## Filter Examples
	// ```json
	// [
	//
	//	{
	//	  "type": "datetime",
	//	  "column": "timestamp",
	//	  "operator": ">=",
	//	  "value": "2024-01-01T00:00:00Z"
	//	},
	//	{
	//	  "type": "string",
	//	  "column": "userId",
	//	  "operator": "=",
	//	  "value": "user-123"
	//	},
	//	{
	//	  "type": "number",
	//	  "column": "totalCost",
	//	  "operator": ">=",
	//	  "value": 0.01
	//	},
	//	{
	//	  "type": "arrayOptions",
	//	  "column": "tags",
	//	  "operator": "all of",
	//	  "value": ["production", "critical"]
	//	},
	//	{
	//	  "type": "stringObject",
	//	  "column": "metadata",
	//	  "key": "customer_tier",
	//	  "operator": "=",
	//	  "value": "enterprise"
	//	}
	//
	// ]
	// ```
	//
	// ## Performance Notes
	// - Filtering on `userId`, `sessionId`, or `metadata` may enable skip indexes for better query performance
	// - Score filters require a join with the scores table and may impact query performance
	Filter *string `json:"-" url:"filter,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (t *TraceListRequest) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetPage(page *int) {
	t.Page = page
	t.require(traceListRequestFieldPage)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetLimit(limit *int) {
	t.Limit = limit
	t.require(traceListRequestFieldLimit)
}

// SetUserID sets the UserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetUserID(userID *string) {
	t.UserID = userID
	t.require(traceListRequestFieldUserID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetName(name *string) {
	t.Name = name
	t.require(traceListRequestFieldName)
}

// SetSessionID sets the SessionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetSessionID(sessionID *string) {
	t.SessionID = sessionID
	t.require(traceListRequestFieldSessionID)
}

// SetFromTimestamp sets the FromTimestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetFromTimestamp(fromTimestamp *time.Time) {
	t.FromTimestamp = fromTimestamp
	t.require(traceListRequestFieldFromTimestamp)
}

// SetToTimestamp sets the ToTimestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetToTimestamp(toTimestamp *time.Time) {
	t.ToTimestamp = toTimestamp
	t.require(traceListRequestFieldToTimestamp)
}

// SetOrderBy sets the OrderBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetOrderBy(orderBy *string) {
	t.OrderBy = orderBy
	t.require(traceListRequestFieldOrderBy)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetTags(tags []*string) {
	t.Tags = tags
	t.require(traceListRequestFieldTags)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetVersion(version *string) {
	t.Version = version
	t.require(traceListRequestFieldVersion)
}

// SetRelease sets the Release field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetRelease(release *string) {
	t.Release = release
	t.require(traceListRequestFieldRelease)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetEnvironment(environment []*string) {
	t.Environment = environment
	t.require(traceListRequestFieldEnvironment)
}

// SetFields sets the Fields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetFields(fields *string) {
	t.Fields = fields
	t.require(traceListRequestFieldFields)
}

// SetFilter sets the Filter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceListRequest) SetFilter(filter *string) {
	t.Filter = filter
	t.require(traceListRequestFieldFilter)
}

var (
	baseScoreV1FieldID            = big.NewInt(1 << 0)
	baseScoreV1FieldTraceID       = big.NewInt(1 << 1)
	baseScoreV1FieldName          = big.NewInt(1 << 2)
	baseScoreV1FieldSource        = big.NewInt(1 << 3)
	baseScoreV1FieldObservationID = big.NewInt(1 << 4)
	baseScoreV1FieldTimestamp     = big.NewInt(1 << 5)
	baseScoreV1FieldCreatedAt     = big.NewInt(1 << 6)
	baseScoreV1FieldUpdatedAt     = big.NewInt(1 << 7)
	baseScoreV1FieldAuthorUserID  = big.NewInt(1 << 8)
	baseScoreV1FieldComment       = big.NewInt(1 << 9)
	baseScoreV1FieldMetadata      = big.NewInt(1 << 10)
	baseScoreV1FieldConfigID      = big.NewInt(1 << 11)
	baseScoreV1FieldQueueID       = big.NewInt(1 << 12)
	baseScoreV1FieldEnvironment   = big.NewInt(1 << 13)
)

type BaseScoreV1 struct {
	ID      string      `json:"id" url:"id"`
	TraceID string      `json:"traceId" url:"traceId"`
	Name    string      `json:"name" url:"name"`
	Source  ScoreSource `json:"source" url:"source"`
	// The observation ID associated with the score
	ObservationID *string   `json:"observationId,omitempty" url:"observationId,omitempty"`
	Timestamp     time.Time `json:"timestamp" url:"timestamp"`
	CreatedAt     time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt" url:"updatedAt"`
	// The user ID of the author
	AuthorUserID *string `json:"authorUserId,omitempty" url:"authorUserId,omitempty"`
	// Comment on the score
	Comment  *string     `json:"comment,omitempty" url:"comment,omitempty"`
	Metadata interface{} `json:"metadata" url:"metadata"`
	// Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigID *string `json:"configId,omitempty" url:"configId,omitempty"`
	// The annotation queue referenced by the score. Indicates if score was initially created while processing annotation queue.
	QueueID *string `json:"queueId,omitempty" url:"queueId,omitempty"`
	// The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment string `json:"environment" url:"environment"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseScoreV1) GetID() string {
	if b == nil {
		return ""
	}
	return b.ID
}

func (b *BaseScoreV1) GetTraceID() string {
	if b == nil {
		return ""
	}
	return b.TraceID
}

func (b *BaseScoreV1) GetName() string {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *BaseScoreV1) GetSource() ScoreSource {
	if b == nil {
		return ""
	}
	return b.Source
}

func (b *BaseScoreV1) GetObservationID() *string {
	if b == nil {
		return nil
	}
	return b.ObservationID
}

func (b *BaseScoreV1) GetTimestamp() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.Timestamp
}

func (b *BaseScoreV1) GetCreatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.CreatedAt
}

func (b *BaseScoreV1) GetUpdatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.UpdatedAt
}

func (b *BaseScoreV1) GetAuthorUserID() *string {
	if b == nil {
		return nil
	}
	return b.AuthorUserID
}

func (b *BaseScoreV1) GetComment() *string {
	if b == nil {
		return nil
	}
	return b.Comment
}

func (b *BaseScoreV1) GetMetadata() interface{} {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BaseScoreV1) GetConfigID() *string {
	if b == nil {
		return nil
	}
	return b.ConfigID
}

func (b *BaseScoreV1) GetQueueID() *string {
	if b == nil {
		return nil
	}
	return b.QueueID
}

func (b *BaseScoreV1) GetEnvironment() string {
	if b == nil {
		return ""
	}
	return b.Environment
}

func (b *BaseScoreV1) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseScoreV1) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetID(id string) {
	b.ID = id
	b.require(baseScoreV1FieldID)
}

// SetTraceID sets the TraceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetTraceID(traceID string) {
	b.TraceID = traceID
	b.require(baseScoreV1FieldTraceID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetName(name string) {
	b.Name = name
	b.require(baseScoreV1FieldName)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetSource(source ScoreSource) {
	b.Source = source
	b.require(baseScoreV1FieldSource)
}

// SetObservationID sets the ObservationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetObservationID(observationID *string) {
	b.ObservationID = observationID
	b.require(baseScoreV1FieldObservationID)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetTimestamp(timestamp time.Time) {
	b.Timestamp = timestamp
	b.require(baseScoreV1FieldTimestamp)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetCreatedAt(createdAt time.Time) {
	b.CreatedAt = createdAt
	b.require(baseScoreV1FieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetUpdatedAt(updatedAt time.Time) {
	b.UpdatedAt = updatedAt
	b.require(baseScoreV1FieldUpdatedAt)
}

// SetAuthorUserID sets the AuthorUserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetAuthorUserID(authorUserID *string) {
	b.AuthorUserID = authorUserID
	b.require(baseScoreV1FieldAuthorUserID)
}

// SetComment sets the Comment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetComment(comment *string) {
	b.Comment = comment
	b.require(baseScoreV1FieldComment)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetMetadata(metadata interface{}) {
	b.Metadata = metadata
	b.require(baseScoreV1FieldMetadata)
}

// SetConfigID sets the ConfigID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetConfigID(configID *string) {
	b.ConfigID = configID
	b.require(baseScoreV1FieldConfigID)
}

// SetQueueID sets the QueueID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetQueueID(queueID *string) {
	b.QueueID = queueID
	b.require(baseScoreV1FieldQueueID)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseScoreV1) SetEnvironment(environment string) {
	b.Environment = environment
	b.require(baseScoreV1FieldEnvironment)
}

func (b *BaseScoreV1) UnmarshalJSON(data []byte) error {
	type embed BaseScoreV1
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BaseScoreV1(unmarshaler.embed)
	b.Timestamp = unmarshaler.Timestamp.Time()
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseScoreV1) MarshalJSON() ([]byte, error) {
	type embed BaseScoreV1
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*b),
		Timestamp: internal.NewDateTime(b.Timestamp),
		CreatedAt: internal.NewDateTime(b.CreatedAt),
		UpdatedAt: internal.NewDateTime(b.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseScoreV1) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	booleanScoreV1FieldID            = big.NewInt(1 << 0)
	booleanScoreV1FieldTraceID       = big.NewInt(1 << 1)
	booleanScoreV1FieldName          = big.NewInt(1 << 2)
	booleanScoreV1FieldSource        = big.NewInt(1 << 3)
	booleanScoreV1FieldObservationID = big.NewInt(1 << 4)
	booleanScoreV1FieldTimestamp     = big.NewInt(1 << 5)
	booleanScoreV1FieldCreatedAt     = big.NewInt(1 << 6)
	booleanScoreV1FieldUpdatedAt     = big.NewInt(1 << 7)
	booleanScoreV1FieldAuthorUserID  = big.NewInt(1 << 8)
	booleanScoreV1FieldComment       = big.NewInt(1 << 9)
	booleanScoreV1FieldMetadata      = big.NewInt(1 << 10)
	booleanScoreV1FieldConfigID      = big.NewInt(1 << 11)
	booleanScoreV1FieldQueueID       = big.NewInt(1 << 12)
	booleanScoreV1FieldEnvironment   = big.NewInt(1 << 13)
	booleanScoreV1FieldValue         = big.NewInt(1 << 14)
	booleanScoreV1FieldStringValue   = big.NewInt(1 << 15)
)

type BooleanScoreV1 struct {
	ID      string      `json:"id" url:"id"`
	TraceID string      `json:"traceId" url:"traceId"`
	Name    string      `json:"name" url:"name"`
	Source  ScoreSource `json:"source" url:"source"`
	// The observation ID associated with the score
	ObservationID *string   `json:"observationId,omitempty" url:"observationId,omitempty"`
	Timestamp     time.Time `json:"timestamp" url:"timestamp"`
	CreatedAt     time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt" url:"updatedAt"`
	// The user ID of the author
	AuthorUserID *string `json:"authorUserId,omitempty" url:"authorUserId,omitempty"`
	// Comment on the score
	Comment  *string     `json:"comment,omitempty" url:"comment,omitempty"`
	Metadata interface{} `json:"metadata" url:"metadata"`
	// Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigID *string `json:"configId,omitempty" url:"configId,omitempty"`
	// The annotation queue referenced by the score. Indicates if score was initially created while processing annotation queue.
	QueueID *string `json:"queueId,omitempty" url:"queueId,omitempty"`
	// The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment string `json:"environment" url:"environment"`
	// The numeric value of the score. Equals 1 for "True" and 0 for "False"
	Value float64 `json:"value" url:"value"`
	// The string representation of the score value. Is inferred from the numeric value and equals "True" or "False"
	StringValue string `json:"stringValue" url:"stringValue"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BooleanScoreV1) GetID() string {
	if b == nil {
		return ""
	}
	return b.ID
}

func (b *BooleanScoreV1) GetTraceID() string {
	if b == nil {
		return ""
	}
	return b.TraceID
}

func (b *BooleanScoreV1) GetName() string {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *BooleanScoreV1) GetSource() ScoreSource {
	if b == nil {
		return ""
	}
	return b.Source
}

func (b *BooleanScoreV1) GetObservationID() *string {
	if b == nil {
		return nil
	}
	return b.ObservationID
}

func (b *BooleanScoreV1) GetTimestamp() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.Timestamp
}

func (b *BooleanScoreV1) GetCreatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.CreatedAt
}

func (b *BooleanScoreV1) GetUpdatedAt() time.Time {
	if b == nil {
		return time.Time{}
	}
	return b.UpdatedAt
}

func (b *BooleanScoreV1) GetAuthorUserID() *string {
	if b == nil {
		return nil
	}
	return b.AuthorUserID
}

func (b *BooleanScoreV1) GetComment() *string {
	if b == nil {
		return nil
	}
	return b.Comment
}

func (b *BooleanScoreV1) GetMetadata() interface{} {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BooleanScoreV1) GetConfigID() *string {
	if b == nil {
		return nil
	}
	return b.ConfigID
}

func (b *BooleanScoreV1) GetQueueID() *string {
	if b == nil {
		return nil
	}
	return b.QueueID
}

func (b *BooleanScoreV1) GetEnvironment() string {
	if b == nil {
		return ""
	}
	return b.Environment
}

func (b *BooleanScoreV1) GetValue() float64 {
	if b == nil {
		return 0
	}
	return b.Value
}

func (b *BooleanScoreV1) GetStringValue() string {
	if b == nil {
		return ""
	}
	return b.StringValue
}

func (b *BooleanScoreV1) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BooleanScoreV1) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetID(id string) {
	b.ID = id
	b.require(booleanScoreV1FieldID)
}

// SetTraceID sets the TraceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetTraceID(traceID string) {
	b.TraceID = traceID
	b.require(booleanScoreV1FieldTraceID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetName(name string) {
	b.Name = name
	b.require(booleanScoreV1FieldName)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetSource(source ScoreSource) {
	b.Source = source
	b.require(booleanScoreV1FieldSource)
}

// SetObservationID sets the ObservationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetObservationID(observationID *string) {
	b.ObservationID = observationID
	b.require(booleanScoreV1FieldObservationID)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetTimestamp(timestamp time.Time) {
	b.Timestamp = timestamp
	b.require(booleanScoreV1FieldTimestamp)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetCreatedAt(createdAt time.Time) {
	b.CreatedAt = createdAt
	b.require(booleanScoreV1FieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetUpdatedAt(updatedAt time.Time) {
	b.UpdatedAt = updatedAt
	b.require(booleanScoreV1FieldUpdatedAt)
}

// SetAuthorUserID sets the AuthorUserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetAuthorUserID(authorUserID *string) {
	b.AuthorUserID = authorUserID
	b.require(booleanScoreV1FieldAuthorUserID)
}

// SetComment sets the Comment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetComment(comment *string) {
	b.Comment = comment
	b.require(booleanScoreV1FieldComment)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetMetadata(metadata interface{}) {
	b.Metadata = metadata
	b.require(booleanScoreV1FieldMetadata)
}

// SetConfigID sets the ConfigID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetConfigID(configID *string) {
	b.ConfigID = configID
	b.require(booleanScoreV1FieldConfigID)
}

// SetQueueID sets the QueueID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetQueueID(queueID *string) {
	b.QueueID = queueID
	b.require(booleanScoreV1FieldQueueID)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetEnvironment(environment string) {
	b.Environment = environment
	b.require(booleanScoreV1FieldEnvironment)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetValue(value float64) {
	b.Value = value
	b.require(booleanScoreV1FieldValue)
}

// SetStringValue sets the StringValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanScoreV1) SetStringValue(stringValue string) {
	b.StringValue = stringValue
	b.require(booleanScoreV1FieldStringValue)
}

func (b *BooleanScoreV1) UnmarshalJSON(data []byte) error {
	type embed BooleanScoreV1
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BooleanScoreV1(unmarshaler.embed)
	b.Timestamp = unmarshaler.Timestamp.Time()
	b.CreatedAt = unmarshaler.CreatedAt.Time()
	b.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BooleanScoreV1) MarshalJSON() ([]byte, error) {
	type embed BooleanScoreV1
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*b),
		Timestamp: internal.NewDateTime(b.Timestamp),
		CreatedAt: internal.NewDateTime(b.CreatedAt),
		UpdatedAt: internal.NewDateTime(b.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BooleanScoreV1) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	categoricalScoreV1FieldID            = big.NewInt(1 << 0)
	categoricalScoreV1FieldTraceID       = big.NewInt(1 << 1)
	categoricalScoreV1FieldName          = big.NewInt(1 << 2)
	categoricalScoreV1FieldSource        = big.NewInt(1 << 3)
	categoricalScoreV1FieldObservationID = big.NewInt(1 << 4)
	categoricalScoreV1FieldTimestamp     = big.NewInt(1 << 5)
	categoricalScoreV1FieldCreatedAt     = big.NewInt(1 << 6)
	categoricalScoreV1FieldUpdatedAt     = big.NewInt(1 << 7)
	categoricalScoreV1FieldAuthorUserID  = big.NewInt(1 << 8)
	categoricalScoreV1FieldComment       = big.NewInt(1 << 9)
	categoricalScoreV1FieldMetadata      = big.NewInt(1 << 10)
	categoricalScoreV1FieldConfigID      = big.NewInt(1 << 11)
	categoricalScoreV1FieldQueueID       = big.NewInt(1 << 12)
	categoricalScoreV1FieldEnvironment   = big.NewInt(1 << 13)
	categoricalScoreV1FieldValue         = big.NewInt(1 << 14)
	categoricalScoreV1FieldStringValue   = big.NewInt(1 << 15)
)

type CategoricalScoreV1 struct {
	ID      string      `json:"id" url:"id"`
	TraceID string      `json:"traceId" url:"traceId"`
	Name    string      `json:"name" url:"name"`
	Source  ScoreSource `json:"source" url:"source"`
	// The observation ID associated with the score
	ObservationID *string   `json:"observationId,omitempty" url:"observationId,omitempty"`
	Timestamp     time.Time `json:"timestamp" url:"timestamp"`
	CreatedAt     time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt" url:"updatedAt"`
	// The user ID of the author
	AuthorUserID *string `json:"authorUserId,omitempty" url:"authorUserId,omitempty"`
	// Comment on the score
	Comment  *string     `json:"comment,omitempty" url:"comment,omitempty"`
	Metadata interface{} `json:"metadata" url:"metadata"`
	// Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigID *string `json:"configId,omitempty" url:"configId,omitempty"`
	// The annotation queue referenced by the score. Indicates if score was initially created while processing annotation queue.
	QueueID *string `json:"queueId,omitempty" url:"queueId,omitempty"`
	// The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment string `json:"environment" url:"environment"`
	// Represents the numeric category mapping of the stringValue. If no config is linked, defaults to 0.
	Value float64 `json:"value" url:"value"`
	// The string representation of the score value. If no config is linked, can be any string. Otherwise, must map to a config category
	StringValue string `json:"stringValue" url:"stringValue"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CategoricalScoreV1) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CategoricalScoreV1) GetTraceID() string {
	if c == nil {
		return ""
	}
	return c.TraceID
}

func (c *CategoricalScoreV1) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CategoricalScoreV1) GetSource() ScoreSource {
	if c == nil {
		return ""
	}
	return c.Source
}

func (c *CategoricalScoreV1) GetObservationID() *string {
	if c == nil {
		return nil
	}
	return c.ObservationID
}

func (c *CategoricalScoreV1) GetTimestamp() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.Timestamp
}

func (c *CategoricalScoreV1) GetCreatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.CreatedAt
}

func (c *CategoricalScoreV1) GetUpdatedAt() time.Time {
	if c == nil {
		return time.Time{}
	}
	return c.UpdatedAt
}

func (c *CategoricalScoreV1) GetAuthorUserID() *string {
	if c == nil {
		return nil
	}
	return c.AuthorUserID
}

func (c *CategoricalScoreV1) GetComment() *string {
	if c == nil {
		return nil
	}
	return c.Comment
}

func (c *CategoricalScoreV1) GetMetadata() interface{} {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *CategoricalScoreV1) GetConfigID() *string {
	if c == nil {
		return nil
	}
	return c.ConfigID
}

func (c *CategoricalScoreV1) GetQueueID() *string {
	if c == nil {
		return nil
	}
	return c.QueueID
}

func (c *CategoricalScoreV1) GetEnvironment() string {
	if c == nil {
		return ""
	}
	return c.Environment
}

func (c *CategoricalScoreV1) GetValue() float64 {
	if c == nil {
		return 0
	}
	return c.Value
}

func (c *CategoricalScoreV1) GetStringValue() string {
	if c == nil {
		return ""
	}
	return c.StringValue
}

func (c *CategoricalScoreV1) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CategoricalScoreV1) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetID(id string) {
	c.ID = id
	c.require(categoricalScoreV1FieldID)
}

// SetTraceID sets the TraceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetTraceID(traceID string) {
	c.TraceID = traceID
	c.require(categoricalScoreV1FieldTraceID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetName(name string) {
	c.Name = name
	c.require(categoricalScoreV1FieldName)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetSource(source ScoreSource) {
	c.Source = source
	c.require(categoricalScoreV1FieldSource)
}

// SetObservationID sets the ObservationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetObservationID(observationID *string) {
	c.ObservationID = observationID
	c.require(categoricalScoreV1FieldObservationID)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetTimestamp(timestamp time.Time) {
	c.Timestamp = timestamp
	c.require(categoricalScoreV1FieldTimestamp)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetCreatedAt(createdAt time.Time) {
	c.CreatedAt = createdAt
	c.require(categoricalScoreV1FieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetUpdatedAt(updatedAt time.Time) {
	c.UpdatedAt = updatedAt
	c.require(categoricalScoreV1FieldUpdatedAt)
}

// SetAuthorUserID sets the AuthorUserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetAuthorUserID(authorUserID *string) {
	c.AuthorUserID = authorUserID
	c.require(categoricalScoreV1FieldAuthorUserID)
}

// SetComment sets the Comment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetComment(comment *string) {
	c.Comment = comment
	c.require(categoricalScoreV1FieldComment)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetMetadata(metadata interface{}) {
	c.Metadata = metadata
	c.require(categoricalScoreV1FieldMetadata)
}

// SetConfigID sets the ConfigID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetConfigID(configID *string) {
	c.ConfigID = configID
	c.require(categoricalScoreV1FieldConfigID)
}

// SetQueueID sets the QueueID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetQueueID(queueID *string) {
	c.QueueID = queueID
	c.require(categoricalScoreV1FieldQueueID)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetEnvironment(environment string) {
	c.Environment = environment
	c.require(categoricalScoreV1FieldEnvironment)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetValue(value float64) {
	c.Value = value
	c.require(categoricalScoreV1FieldValue)
}

// SetStringValue sets the StringValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategoricalScoreV1) SetStringValue(stringValue string) {
	c.StringValue = stringValue
	c.require(categoricalScoreV1FieldStringValue)
}

func (c *CategoricalScoreV1) UnmarshalJSON(data []byte) error {
	type embed CategoricalScoreV1
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CategoricalScoreV1(unmarshaler.embed)
	c.Timestamp = unmarshaler.Timestamp.Time()
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CategoricalScoreV1) MarshalJSON() ([]byte, error) {
	type embed CategoricalScoreV1
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*c),
		Timestamp: internal.NewDateTime(c.Timestamp),
		CreatedAt: internal.NewDateTime(c.CreatedAt),
		UpdatedAt: internal.NewDateTime(c.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CategoricalScoreV1) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	deleteTraceResponseFieldMessage = big.NewInt(1 << 0)
)

type DeleteTraceResponse struct {
	Message string `json:"message" url:"message"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteTraceResponse) GetMessage() string {
	if d == nil {
		return ""
	}
	return d.Message
}

func (d *DeleteTraceResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteTraceResponse) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteTraceResponse) SetMessage(message string) {
	d.Message = message
	d.require(deleteTraceResponseFieldMessage)
}

func (d *DeleteTraceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteTraceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteTraceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteTraceResponse) MarshalJSON() ([]byte, error) {
	type embed DeleteTraceResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeleteTraceResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	numericScoreV1FieldID            = big.NewInt(1 << 0)
	numericScoreV1FieldTraceID       = big.NewInt(1 << 1)
	numericScoreV1FieldName          = big.NewInt(1 << 2)
	numericScoreV1FieldSource        = big.NewInt(1 << 3)
	numericScoreV1FieldObservationID = big.NewInt(1 << 4)
	numericScoreV1FieldTimestamp     = big.NewInt(1 << 5)
	numericScoreV1FieldCreatedAt     = big.NewInt(1 << 6)
	numericScoreV1FieldUpdatedAt     = big.NewInt(1 << 7)
	numericScoreV1FieldAuthorUserID  = big.NewInt(1 << 8)
	numericScoreV1FieldComment       = big.NewInt(1 << 9)
	numericScoreV1FieldMetadata      = big.NewInt(1 << 10)
	numericScoreV1FieldConfigID      = big.NewInt(1 << 11)
	numericScoreV1FieldQueueID       = big.NewInt(1 << 12)
	numericScoreV1FieldEnvironment   = big.NewInt(1 << 13)
	numericScoreV1FieldValue         = big.NewInt(1 << 14)
)

type NumericScoreV1 struct {
	ID      string      `json:"id" url:"id"`
	TraceID string      `json:"traceId" url:"traceId"`
	Name    string      `json:"name" url:"name"`
	Source  ScoreSource `json:"source" url:"source"`
	// The observation ID associated with the score
	ObservationID *string   `json:"observationId,omitempty" url:"observationId,omitempty"`
	Timestamp     time.Time `json:"timestamp" url:"timestamp"`
	CreatedAt     time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt" url:"updatedAt"`
	// The user ID of the author
	AuthorUserID *string `json:"authorUserId,omitempty" url:"authorUserId,omitempty"`
	// Comment on the score
	Comment  *string     `json:"comment,omitempty" url:"comment,omitempty"`
	Metadata interface{} `json:"metadata" url:"metadata"`
	// Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigID *string `json:"configId,omitempty" url:"configId,omitempty"`
	// The annotation queue referenced by the score. Indicates if score was initially created while processing annotation queue.
	QueueID *string `json:"queueId,omitempty" url:"queueId,omitempty"`
	// The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment string `json:"environment" url:"environment"`
	// The numeric value of the score
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NumericScoreV1) GetID() string {
	if n == nil {
		return ""
	}
	return n.ID
}

func (n *NumericScoreV1) GetTraceID() string {
	if n == nil {
		return ""
	}
	return n.TraceID
}

func (n *NumericScoreV1) GetName() string {
	if n == nil {
		return ""
	}
	return n.Name
}

func (n *NumericScoreV1) GetSource() ScoreSource {
	if n == nil {
		return ""
	}
	return n.Source
}

func (n *NumericScoreV1) GetObservationID() *string {
	if n == nil {
		return nil
	}
	return n.ObservationID
}

func (n *NumericScoreV1) GetTimestamp() time.Time {
	if n == nil {
		return time.Time{}
	}
	return n.Timestamp
}

func (n *NumericScoreV1) GetCreatedAt() time.Time {
	if n == nil {
		return time.Time{}
	}
	return n.CreatedAt
}

func (n *NumericScoreV1) GetUpdatedAt() time.Time {
	if n == nil {
		return time.Time{}
	}
	return n.UpdatedAt
}

func (n *NumericScoreV1) GetAuthorUserID() *string {
	if n == nil {
		return nil
	}
	return n.AuthorUserID
}

func (n *NumericScoreV1) GetComment() *string {
	if n == nil {
		return nil
	}
	return n.Comment
}

func (n *NumericScoreV1) GetMetadata() interface{} {
	if n == nil {
		return nil
	}
	return n.Metadata
}

func (n *NumericScoreV1) GetConfigID() *string {
	if n == nil {
		return nil
	}
	return n.ConfigID
}

func (n *NumericScoreV1) GetQueueID() *string {
	if n == nil {
		return nil
	}
	return n.QueueID
}

func (n *NumericScoreV1) GetEnvironment() string {
	if n == nil {
		return ""
	}
	return n.Environment
}

func (n *NumericScoreV1) GetValue() float64 {
	if n == nil {
		return 0
	}
	return n.Value
}

func (n *NumericScoreV1) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NumericScoreV1) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetID(id string) {
	n.ID = id
	n.require(numericScoreV1FieldID)
}

// SetTraceID sets the TraceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetTraceID(traceID string) {
	n.TraceID = traceID
	n.require(numericScoreV1FieldTraceID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetName(name string) {
	n.Name = name
	n.require(numericScoreV1FieldName)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetSource(source ScoreSource) {
	n.Source = source
	n.require(numericScoreV1FieldSource)
}

// SetObservationID sets the ObservationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetObservationID(observationID *string) {
	n.ObservationID = observationID
	n.require(numericScoreV1FieldObservationID)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetTimestamp(timestamp time.Time) {
	n.Timestamp = timestamp
	n.require(numericScoreV1FieldTimestamp)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetCreatedAt(createdAt time.Time) {
	n.CreatedAt = createdAt
	n.require(numericScoreV1FieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetUpdatedAt(updatedAt time.Time) {
	n.UpdatedAt = updatedAt
	n.require(numericScoreV1FieldUpdatedAt)
}

// SetAuthorUserID sets the AuthorUserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetAuthorUserID(authorUserID *string) {
	n.AuthorUserID = authorUserID
	n.require(numericScoreV1FieldAuthorUserID)
}

// SetComment sets the Comment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetComment(comment *string) {
	n.Comment = comment
	n.require(numericScoreV1FieldComment)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetMetadata(metadata interface{}) {
	n.Metadata = metadata
	n.require(numericScoreV1FieldMetadata)
}

// SetConfigID sets the ConfigID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetConfigID(configID *string) {
	n.ConfigID = configID
	n.require(numericScoreV1FieldConfigID)
}

// SetQueueID sets the QueueID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetQueueID(queueID *string) {
	n.QueueID = queueID
	n.require(numericScoreV1FieldQueueID)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetEnvironment(environment string) {
	n.Environment = environment
	n.require(numericScoreV1FieldEnvironment)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericScoreV1) SetValue(value float64) {
	n.Value = value
	n.require(numericScoreV1FieldValue)
}

func (n *NumericScoreV1) UnmarshalJSON(data []byte) error {
	type embed NumericScoreV1
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NumericScoreV1(unmarshaler.embed)
	n.Timestamp = unmarshaler.Timestamp.Time()
	n.CreatedAt = unmarshaler.CreatedAt.Time()
	n.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumericScoreV1) MarshalJSON() ([]byte, error) {
	type embed NumericScoreV1
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*n),
		Timestamp: internal.NewDateTime(n.Timestamp),
		CreatedAt: internal.NewDateTime(n.CreatedAt),
		UpdatedAt: internal.NewDateTime(n.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NumericScoreV1) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type ScoreV1 struct {
	ScoreV1Zero *ScoreV1Zero
	ScoreV1One  *ScoreV1One
	ScoreV1Two  *ScoreV1Two

	typ string
}

func (s *ScoreV1) GetScoreV1Zero() *ScoreV1Zero {
	if s == nil {
		return nil
	}
	return s.ScoreV1Zero
}

func (s *ScoreV1) GetScoreV1One() *ScoreV1One {
	if s == nil {
		return nil
	}
	return s.ScoreV1One
}

func (s *ScoreV1) GetScoreV1Two() *ScoreV1Two {
	if s == nil {
		return nil
	}
	return s.ScoreV1Two
}

func (s *ScoreV1) UnmarshalJSON(data []byte) error {
	valueScoreV1Zero := new(ScoreV1Zero)
	if err := json.Unmarshal(data, &valueScoreV1Zero); err == nil {
		s.typ = "ScoreV1Zero"
		s.ScoreV1Zero = valueScoreV1Zero
		return nil
	}
	valueScoreV1One := new(ScoreV1One)
	if err := json.Unmarshal(data, &valueScoreV1One); err == nil {
		s.typ = "ScoreV1One"
		s.ScoreV1One = valueScoreV1One
		return nil
	}
	valueScoreV1Two := new(ScoreV1Two)
	if err := json.Unmarshal(data, &valueScoreV1Two); err == nil {
		s.typ = "ScoreV1Two"
		s.ScoreV1Two = valueScoreV1Two
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ScoreV1) MarshalJSON() ([]byte, error) {
	if s.typ == "ScoreV1Zero" || s.ScoreV1Zero != nil {
		return json.Marshal(s.ScoreV1Zero)
	}
	if s.typ == "ScoreV1One" || s.ScoreV1One != nil {
		return json.Marshal(s.ScoreV1One)
	}
	if s.typ == "ScoreV1Two" || s.ScoreV1Two != nil {
		return json.Marshal(s.ScoreV1Two)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", s)
}

type ScoreV1Visitor interface {
	VisitScoreV1Zero(*ScoreV1Zero) error
	VisitScoreV1One(*ScoreV1One) error
	VisitScoreV1Two(*ScoreV1Two) error
}

func (s *ScoreV1) Accept(visitor ScoreV1Visitor) error {
	if s.typ == "ScoreV1Zero" || s.ScoreV1Zero != nil {
		return visitor.VisitScoreV1Zero(s.ScoreV1Zero)
	}
	if s.typ == "ScoreV1One" || s.ScoreV1One != nil {
		return visitor.VisitScoreV1One(s.ScoreV1One)
	}
	if s.typ == "ScoreV1Two" || s.ScoreV1Two != nil {
		return visitor.VisitScoreV1Two(s.ScoreV1Two)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", s)
}

var (
	scoreV1OneFieldID            = big.NewInt(1 << 0)
	scoreV1OneFieldTraceID       = big.NewInt(1 << 1)
	scoreV1OneFieldName          = big.NewInt(1 << 2)
	scoreV1OneFieldSource        = big.NewInt(1 << 3)
	scoreV1OneFieldObservationID = big.NewInt(1 << 4)
	scoreV1OneFieldTimestamp     = big.NewInt(1 << 5)
	scoreV1OneFieldCreatedAt     = big.NewInt(1 << 6)
	scoreV1OneFieldUpdatedAt     = big.NewInt(1 << 7)
	scoreV1OneFieldAuthorUserID  = big.NewInt(1 << 8)
	scoreV1OneFieldComment       = big.NewInt(1 << 9)
	scoreV1OneFieldMetadata      = big.NewInt(1 << 10)
	scoreV1OneFieldConfigID      = big.NewInt(1 << 11)
	scoreV1OneFieldQueueID       = big.NewInt(1 << 12)
	scoreV1OneFieldEnvironment   = big.NewInt(1 << 13)
	scoreV1OneFieldValue         = big.NewInt(1 << 14)
	scoreV1OneFieldStringValue   = big.NewInt(1 << 15)
	scoreV1OneFieldDataType      = big.NewInt(1 << 16)
)

type ScoreV1One struct {
	ID      string      `json:"id" url:"id"`
	TraceID string      `json:"traceId" url:"traceId"`
	Name    string      `json:"name" url:"name"`
	Source  ScoreSource `json:"source" url:"source"`
	// The observation ID associated with the score
	ObservationID *string   `json:"observationId,omitempty" url:"observationId,omitempty"`
	Timestamp     time.Time `json:"timestamp" url:"timestamp"`
	CreatedAt     time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt" url:"updatedAt"`
	// The user ID of the author
	AuthorUserID *string `json:"authorUserId,omitempty" url:"authorUserId,omitempty"`
	// Comment on the score
	Comment  *string     `json:"comment,omitempty" url:"comment,omitempty"`
	Metadata interface{} `json:"metadata" url:"metadata"`
	// Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigID *string `json:"configId,omitempty" url:"configId,omitempty"`
	// The annotation queue referenced by the score. Indicates if score was initially created while processing annotation queue.
	QueueID *string `json:"queueId,omitempty" url:"queueId,omitempty"`
	// The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment string `json:"environment" url:"environment"`
	// Represents the numeric category mapping of the stringValue. If no config is linked, defaults to 0.
	Value float64 `json:"value" url:"value"`
	// The string representation of the score value. If no config is linked, can be any string. Otherwise, must map to a config category
	StringValue string              `json:"stringValue" url:"stringValue"`
	DataType    *ScoreV1OneDataType `json:"dataType,omitempty" url:"dataType,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScoreV1One) GetID() string {
	if s == nil {
		return ""
	}
	return s.ID
}

func (s *ScoreV1One) GetTraceID() string {
	if s == nil {
		return ""
	}
	return s.TraceID
}

func (s *ScoreV1One) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *ScoreV1One) GetSource() ScoreSource {
	if s == nil {
		return ""
	}
	return s.Source
}

func (s *ScoreV1One) GetObservationID() *string {
	if s == nil {
		return nil
	}
	return s.ObservationID
}

func (s *ScoreV1One) GetTimestamp() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.Timestamp
}

func (s *ScoreV1One) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *ScoreV1One) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *ScoreV1One) GetAuthorUserID() *string {
	if s == nil {
		return nil
	}
	return s.AuthorUserID
}

func (s *ScoreV1One) GetComment() *string {
	if s == nil {
		return nil
	}
	return s.Comment
}

func (s *ScoreV1One) GetMetadata() interface{} {
	if s == nil {
		return nil
	}
	return s.Metadata
}

func (s *ScoreV1One) GetConfigID() *string {
	if s == nil {
		return nil
	}
	return s.ConfigID
}

func (s *ScoreV1One) GetQueueID() *string {
	if s == nil {
		return nil
	}
	return s.QueueID
}

func (s *ScoreV1One) GetEnvironment() string {
	if s == nil {
		return ""
	}
	return s.Environment
}

func (s *ScoreV1One) GetValue() float64 {
	if s == nil {
		return 0
	}
	return s.Value
}

func (s *ScoreV1One) GetStringValue() string {
	if s == nil {
		return ""
	}
	return s.StringValue
}

func (s *ScoreV1One) GetDataType() *ScoreV1OneDataType {
	if s == nil {
		return nil
	}
	return s.DataType
}

func (s *ScoreV1One) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScoreV1One) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetID(id string) {
	s.ID = id
	s.require(scoreV1OneFieldID)
}

// SetTraceID sets the TraceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetTraceID(traceID string) {
	s.TraceID = traceID
	s.require(scoreV1OneFieldTraceID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetName(name string) {
	s.Name = name
	s.require(scoreV1OneFieldName)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetSource(source ScoreSource) {
	s.Source = source
	s.require(scoreV1OneFieldSource)
}

// SetObservationID sets the ObservationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetObservationID(observationID *string) {
	s.ObservationID = observationID
	s.require(scoreV1OneFieldObservationID)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetTimestamp(timestamp time.Time) {
	s.Timestamp = timestamp
	s.require(scoreV1OneFieldTimestamp)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetCreatedAt(createdAt time.Time) {
	s.CreatedAt = createdAt
	s.require(scoreV1OneFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetUpdatedAt(updatedAt time.Time) {
	s.UpdatedAt = updatedAt
	s.require(scoreV1OneFieldUpdatedAt)
}

// SetAuthorUserID sets the AuthorUserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetAuthorUserID(authorUserID *string) {
	s.AuthorUserID = authorUserID
	s.require(scoreV1OneFieldAuthorUserID)
}

// SetComment sets the Comment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetComment(comment *string) {
	s.Comment = comment
	s.require(scoreV1OneFieldComment)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetMetadata(metadata interface{}) {
	s.Metadata = metadata
	s.require(scoreV1OneFieldMetadata)
}

// SetConfigID sets the ConfigID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetConfigID(configID *string) {
	s.ConfigID = configID
	s.require(scoreV1OneFieldConfigID)
}

// SetQueueID sets the QueueID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetQueueID(queueID *string) {
	s.QueueID = queueID
	s.require(scoreV1OneFieldQueueID)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetEnvironment(environment string) {
	s.Environment = environment
	s.require(scoreV1OneFieldEnvironment)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetValue(value float64) {
	s.Value = value
	s.require(scoreV1OneFieldValue)
}

// SetStringValue sets the StringValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetStringValue(stringValue string) {
	s.StringValue = stringValue
	s.require(scoreV1OneFieldStringValue)
}

// SetDataType sets the DataType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1One) SetDataType(dataType *ScoreV1OneDataType) {
	s.DataType = dataType
	s.require(scoreV1OneFieldDataType)
}

func (s *ScoreV1One) UnmarshalJSON(data []byte) error {
	type embed ScoreV1One
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ScoreV1One(unmarshaler.embed)
	s.Timestamp = unmarshaler.Timestamp.Time()
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScoreV1One) MarshalJSON() ([]byte, error) {
	type embed ScoreV1One
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*s),
		Timestamp: internal.NewDateTime(s.Timestamp),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *ScoreV1One) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScoreV1OneDataType string

const (
	ScoreV1OneDataTypeCategorical ScoreV1OneDataType = "CATEGORICAL"
)

func NewScoreV1OneDataTypeFromString(s string) (ScoreV1OneDataType, error) {
	switch s {
	case "CATEGORICAL":
		return ScoreV1OneDataTypeCategorical, nil
	}
	var t ScoreV1OneDataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScoreV1OneDataType) Ptr() *ScoreV1OneDataType {
	return &s
}

var (
	scoreV1TwoFieldID            = big.NewInt(1 << 0)
	scoreV1TwoFieldTraceID       = big.NewInt(1 << 1)
	scoreV1TwoFieldName          = big.NewInt(1 << 2)
	scoreV1TwoFieldSource        = big.NewInt(1 << 3)
	scoreV1TwoFieldObservationID = big.NewInt(1 << 4)
	scoreV1TwoFieldTimestamp     = big.NewInt(1 << 5)
	scoreV1TwoFieldCreatedAt     = big.NewInt(1 << 6)
	scoreV1TwoFieldUpdatedAt     = big.NewInt(1 << 7)
	scoreV1TwoFieldAuthorUserID  = big.NewInt(1 << 8)
	scoreV1TwoFieldComment       = big.NewInt(1 << 9)
	scoreV1TwoFieldMetadata      = big.NewInt(1 << 10)
	scoreV1TwoFieldConfigID      = big.NewInt(1 << 11)
	scoreV1TwoFieldQueueID       = big.NewInt(1 << 12)
	scoreV1TwoFieldEnvironment   = big.NewInt(1 << 13)
	scoreV1TwoFieldValue         = big.NewInt(1 << 14)
	scoreV1TwoFieldStringValue   = big.NewInt(1 << 15)
	scoreV1TwoFieldDataType      = big.NewInt(1 << 16)
)

type ScoreV1Two struct {
	ID      string      `json:"id" url:"id"`
	TraceID string      `json:"traceId" url:"traceId"`
	Name    string      `json:"name" url:"name"`
	Source  ScoreSource `json:"source" url:"source"`
	// The observation ID associated with the score
	ObservationID *string   `json:"observationId,omitempty" url:"observationId,omitempty"`
	Timestamp     time.Time `json:"timestamp" url:"timestamp"`
	CreatedAt     time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt" url:"updatedAt"`
	// The user ID of the author
	AuthorUserID *string `json:"authorUserId,omitempty" url:"authorUserId,omitempty"`
	// Comment on the score
	Comment  *string     `json:"comment,omitempty" url:"comment,omitempty"`
	Metadata interface{} `json:"metadata" url:"metadata"`
	// Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigID *string `json:"configId,omitempty" url:"configId,omitempty"`
	// The annotation queue referenced by the score. Indicates if score was initially created while processing annotation queue.
	QueueID *string `json:"queueId,omitempty" url:"queueId,omitempty"`
	// The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment string `json:"environment" url:"environment"`
	// The numeric value of the score. Equals 1 for "True" and 0 for "False"
	Value float64 `json:"value" url:"value"`
	// The string representation of the score value. Is inferred from the numeric value and equals "True" or "False"
	StringValue string              `json:"stringValue" url:"stringValue"`
	DataType    *ScoreV1TwoDataType `json:"dataType,omitempty" url:"dataType,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScoreV1Two) GetID() string {
	if s == nil {
		return ""
	}
	return s.ID
}

func (s *ScoreV1Two) GetTraceID() string {
	if s == nil {
		return ""
	}
	return s.TraceID
}

func (s *ScoreV1Two) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *ScoreV1Two) GetSource() ScoreSource {
	if s == nil {
		return ""
	}
	return s.Source
}

func (s *ScoreV1Two) GetObservationID() *string {
	if s == nil {
		return nil
	}
	return s.ObservationID
}

func (s *ScoreV1Two) GetTimestamp() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.Timestamp
}

func (s *ScoreV1Two) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *ScoreV1Two) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *ScoreV1Two) GetAuthorUserID() *string {
	if s == nil {
		return nil
	}
	return s.AuthorUserID
}

func (s *ScoreV1Two) GetComment() *string {
	if s == nil {
		return nil
	}
	return s.Comment
}

func (s *ScoreV1Two) GetMetadata() interface{} {
	if s == nil {
		return nil
	}
	return s.Metadata
}

func (s *ScoreV1Two) GetConfigID() *string {
	if s == nil {
		return nil
	}
	return s.ConfigID
}

func (s *ScoreV1Two) GetQueueID() *string {
	if s == nil {
		return nil
	}
	return s.QueueID
}

func (s *ScoreV1Two) GetEnvironment() string {
	if s == nil {
		return ""
	}
	return s.Environment
}

func (s *ScoreV1Two) GetValue() float64 {
	if s == nil {
		return 0
	}
	return s.Value
}

func (s *ScoreV1Two) GetStringValue() string {
	if s == nil {
		return ""
	}
	return s.StringValue
}

func (s *ScoreV1Two) GetDataType() *ScoreV1TwoDataType {
	if s == nil {
		return nil
	}
	return s.DataType
}

func (s *ScoreV1Two) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScoreV1Two) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetID(id string) {
	s.ID = id
	s.require(scoreV1TwoFieldID)
}

// SetTraceID sets the TraceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetTraceID(traceID string) {
	s.TraceID = traceID
	s.require(scoreV1TwoFieldTraceID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetName(name string) {
	s.Name = name
	s.require(scoreV1TwoFieldName)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetSource(source ScoreSource) {
	s.Source = source
	s.require(scoreV1TwoFieldSource)
}

// SetObservationID sets the ObservationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetObservationID(observationID *string) {
	s.ObservationID = observationID
	s.require(scoreV1TwoFieldObservationID)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetTimestamp(timestamp time.Time) {
	s.Timestamp = timestamp
	s.require(scoreV1TwoFieldTimestamp)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetCreatedAt(createdAt time.Time) {
	s.CreatedAt = createdAt
	s.require(scoreV1TwoFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetUpdatedAt(updatedAt time.Time) {
	s.UpdatedAt = updatedAt
	s.require(scoreV1TwoFieldUpdatedAt)
}

// SetAuthorUserID sets the AuthorUserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetAuthorUserID(authorUserID *string) {
	s.AuthorUserID = authorUserID
	s.require(scoreV1TwoFieldAuthorUserID)
}

// SetComment sets the Comment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetComment(comment *string) {
	s.Comment = comment
	s.require(scoreV1TwoFieldComment)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetMetadata(metadata interface{}) {
	s.Metadata = metadata
	s.require(scoreV1TwoFieldMetadata)
}

// SetConfigID sets the ConfigID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetConfigID(configID *string) {
	s.ConfigID = configID
	s.require(scoreV1TwoFieldConfigID)
}

// SetQueueID sets the QueueID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetQueueID(queueID *string) {
	s.QueueID = queueID
	s.require(scoreV1TwoFieldQueueID)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetEnvironment(environment string) {
	s.Environment = environment
	s.require(scoreV1TwoFieldEnvironment)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetValue(value float64) {
	s.Value = value
	s.require(scoreV1TwoFieldValue)
}

// SetStringValue sets the StringValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetStringValue(stringValue string) {
	s.StringValue = stringValue
	s.require(scoreV1TwoFieldStringValue)
}

// SetDataType sets the DataType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Two) SetDataType(dataType *ScoreV1TwoDataType) {
	s.DataType = dataType
	s.require(scoreV1TwoFieldDataType)
}

func (s *ScoreV1Two) UnmarshalJSON(data []byte) error {
	type embed ScoreV1Two
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ScoreV1Two(unmarshaler.embed)
	s.Timestamp = unmarshaler.Timestamp.Time()
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScoreV1Two) MarshalJSON() ([]byte, error) {
	type embed ScoreV1Two
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*s),
		Timestamp: internal.NewDateTime(s.Timestamp),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *ScoreV1Two) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScoreV1TwoDataType string

const (
	ScoreV1TwoDataTypeBoolean ScoreV1TwoDataType = "BOOLEAN"
)

func NewScoreV1TwoDataTypeFromString(s string) (ScoreV1TwoDataType, error) {
	switch s {
	case "BOOLEAN":
		return ScoreV1TwoDataTypeBoolean, nil
	}
	var t ScoreV1TwoDataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScoreV1TwoDataType) Ptr() *ScoreV1TwoDataType {
	return &s
}

var (
	scoreV1ZeroFieldID            = big.NewInt(1 << 0)
	scoreV1ZeroFieldTraceID       = big.NewInt(1 << 1)
	scoreV1ZeroFieldName          = big.NewInt(1 << 2)
	scoreV1ZeroFieldSource        = big.NewInt(1 << 3)
	scoreV1ZeroFieldObservationID = big.NewInt(1 << 4)
	scoreV1ZeroFieldTimestamp     = big.NewInt(1 << 5)
	scoreV1ZeroFieldCreatedAt     = big.NewInt(1 << 6)
	scoreV1ZeroFieldUpdatedAt     = big.NewInt(1 << 7)
	scoreV1ZeroFieldAuthorUserID  = big.NewInt(1 << 8)
	scoreV1ZeroFieldComment       = big.NewInt(1 << 9)
	scoreV1ZeroFieldMetadata      = big.NewInt(1 << 10)
	scoreV1ZeroFieldConfigID      = big.NewInt(1 << 11)
	scoreV1ZeroFieldQueueID       = big.NewInt(1 << 12)
	scoreV1ZeroFieldEnvironment   = big.NewInt(1 << 13)
	scoreV1ZeroFieldValue         = big.NewInt(1 << 14)
	scoreV1ZeroFieldDataType      = big.NewInt(1 << 15)
)

type ScoreV1Zero struct {
	ID      string      `json:"id" url:"id"`
	TraceID string      `json:"traceId" url:"traceId"`
	Name    string      `json:"name" url:"name"`
	Source  ScoreSource `json:"source" url:"source"`
	// The observation ID associated with the score
	ObservationID *string   `json:"observationId,omitempty" url:"observationId,omitempty"`
	Timestamp     time.Time `json:"timestamp" url:"timestamp"`
	CreatedAt     time.Time `json:"createdAt" url:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt" url:"updatedAt"`
	// The user ID of the author
	AuthorUserID *string `json:"authorUserId,omitempty" url:"authorUserId,omitempty"`
	// Comment on the score
	Comment  *string     `json:"comment,omitempty" url:"comment,omitempty"`
	Metadata interface{} `json:"metadata" url:"metadata"`
	// Reference a score config on a score. When set, config and score name must be equal and value must comply to optionally defined numerical range
	ConfigID *string `json:"configId,omitempty" url:"configId,omitempty"`
	// The annotation queue referenced by the score. Indicates if score was initially created while processing annotation queue.
	QueueID *string `json:"queueId,omitempty" url:"queueId,omitempty"`
	// The environment from which this score originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment string `json:"environment" url:"environment"`
	// The numeric value of the score
	Value    float64              `json:"value" url:"value"`
	DataType *ScoreV1ZeroDataType `json:"dataType,omitempty" url:"dataType,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScoreV1Zero) GetID() string {
	if s == nil {
		return ""
	}
	return s.ID
}

func (s *ScoreV1Zero) GetTraceID() string {
	if s == nil {
		return ""
	}
	return s.TraceID
}

func (s *ScoreV1Zero) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *ScoreV1Zero) GetSource() ScoreSource {
	if s == nil {
		return ""
	}
	return s.Source
}

func (s *ScoreV1Zero) GetObservationID() *string {
	if s == nil {
		return nil
	}
	return s.ObservationID
}

func (s *ScoreV1Zero) GetTimestamp() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.Timestamp
}

func (s *ScoreV1Zero) GetCreatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.CreatedAt
}

func (s *ScoreV1Zero) GetUpdatedAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.UpdatedAt
}

func (s *ScoreV1Zero) GetAuthorUserID() *string {
	if s == nil {
		return nil
	}
	return s.AuthorUserID
}

func (s *ScoreV1Zero) GetComment() *string {
	if s == nil {
		return nil
	}
	return s.Comment
}

func (s *ScoreV1Zero) GetMetadata() interface{} {
	if s == nil {
		return nil
	}
	return s.Metadata
}

func (s *ScoreV1Zero) GetConfigID() *string {
	if s == nil {
		return nil
	}
	return s.ConfigID
}

func (s *ScoreV1Zero) GetQueueID() *string {
	if s == nil {
		return nil
	}
	return s.QueueID
}

func (s *ScoreV1Zero) GetEnvironment() string {
	if s == nil {
		return ""
	}
	return s.Environment
}

func (s *ScoreV1Zero) GetValue() float64 {
	if s == nil {
		return 0
	}
	return s.Value
}

func (s *ScoreV1Zero) GetDataType() *ScoreV1ZeroDataType {
	if s == nil {
		return nil
	}
	return s.DataType
}

func (s *ScoreV1Zero) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScoreV1Zero) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetID(id string) {
	s.ID = id
	s.require(scoreV1ZeroFieldID)
}

// SetTraceID sets the TraceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetTraceID(traceID string) {
	s.TraceID = traceID
	s.require(scoreV1ZeroFieldTraceID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetName(name string) {
	s.Name = name
	s.require(scoreV1ZeroFieldName)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetSource(source ScoreSource) {
	s.Source = source
	s.require(scoreV1ZeroFieldSource)
}

// SetObservationID sets the ObservationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetObservationID(observationID *string) {
	s.ObservationID = observationID
	s.require(scoreV1ZeroFieldObservationID)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetTimestamp(timestamp time.Time) {
	s.Timestamp = timestamp
	s.require(scoreV1ZeroFieldTimestamp)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetCreatedAt(createdAt time.Time) {
	s.CreatedAt = createdAt
	s.require(scoreV1ZeroFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetUpdatedAt(updatedAt time.Time) {
	s.UpdatedAt = updatedAt
	s.require(scoreV1ZeroFieldUpdatedAt)
}

// SetAuthorUserID sets the AuthorUserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetAuthorUserID(authorUserID *string) {
	s.AuthorUserID = authorUserID
	s.require(scoreV1ZeroFieldAuthorUserID)
}

// SetComment sets the Comment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetComment(comment *string) {
	s.Comment = comment
	s.require(scoreV1ZeroFieldComment)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetMetadata(metadata interface{}) {
	s.Metadata = metadata
	s.require(scoreV1ZeroFieldMetadata)
}

// SetConfigID sets the ConfigID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetConfigID(configID *string) {
	s.ConfigID = configID
	s.require(scoreV1ZeroFieldConfigID)
}

// SetQueueID sets the QueueID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetQueueID(queueID *string) {
	s.QueueID = queueID
	s.require(scoreV1ZeroFieldQueueID)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetEnvironment(environment string) {
	s.Environment = environment
	s.require(scoreV1ZeroFieldEnvironment)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetValue(value float64) {
	s.Value = value
	s.require(scoreV1ZeroFieldValue)
}

// SetDataType sets the DataType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScoreV1Zero) SetDataType(dataType *ScoreV1ZeroDataType) {
	s.DataType = dataType
	s.require(scoreV1ZeroFieldDataType)
}

func (s *ScoreV1Zero) UnmarshalJSON(data []byte) error {
	type embed ScoreV1Zero
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = ScoreV1Zero(unmarshaler.embed)
	s.Timestamp = unmarshaler.Timestamp.Time()
	s.CreatedAt = unmarshaler.CreatedAt.Time()
	s.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScoreV1Zero) MarshalJSON() ([]byte, error) {
	type embed ScoreV1Zero
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*s),
		Timestamp: internal.NewDateTime(s.Timestamp),
		CreatedAt: internal.NewDateTime(s.CreatedAt),
		UpdatedAt: internal.NewDateTime(s.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *ScoreV1Zero) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScoreV1ZeroDataType string

const (
	ScoreV1ZeroDataTypeNumeric ScoreV1ZeroDataType = "NUMERIC"
)

func NewScoreV1ZeroDataTypeFromString(s string) (ScoreV1ZeroDataType, error) {
	switch s {
	case "NUMERIC":
		return ScoreV1ZeroDataTypeNumeric, nil
	}
	var t ScoreV1ZeroDataType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScoreV1ZeroDataType) Ptr() *ScoreV1ZeroDataType {
	return &s
}

var (
	traceWithDetailsFieldID           = big.NewInt(1 << 0)
	traceWithDetailsFieldTimestamp    = big.NewInt(1 << 1)
	traceWithDetailsFieldName         = big.NewInt(1 << 2)
	traceWithDetailsFieldInput        = big.NewInt(1 << 3)
	traceWithDetailsFieldOutput       = big.NewInt(1 << 4)
	traceWithDetailsFieldSessionID    = big.NewInt(1 << 5)
	traceWithDetailsFieldRelease      = big.NewInt(1 << 6)
	traceWithDetailsFieldVersion      = big.NewInt(1 << 7)
	traceWithDetailsFieldUserID       = big.NewInt(1 << 8)
	traceWithDetailsFieldMetadata     = big.NewInt(1 << 9)
	traceWithDetailsFieldTags         = big.NewInt(1 << 10)
	traceWithDetailsFieldPublic       = big.NewInt(1 << 11)
	traceWithDetailsFieldEnvironment  = big.NewInt(1 << 12)
	traceWithDetailsFieldHTMLPath     = big.NewInt(1 << 13)
	traceWithDetailsFieldLatency      = big.NewInt(1 << 14)
	traceWithDetailsFieldTotalCost    = big.NewInt(1 << 15)
	traceWithDetailsFieldObservations = big.NewInt(1 << 16)
	traceWithDetailsFieldScores       = big.NewInt(1 << 17)
)

type TraceWithDetails struct {
	// The unique identifier of a trace
	ID string `json:"id" url:"id"`
	// The timestamp when the trace was created
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The name of the trace
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The input data of the trace. Can be any JSON.
	Input interface{} `json:"input,omitempty" url:"input,omitempty"`
	// The output data of the trace. Can be any JSON.
	Output interface{} `json:"output,omitempty" url:"output,omitempty"`
	// The session identifier associated with the trace
	SessionID *string `json:"sessionId,omitempty" url:"sessionId,omitempty"`
	// The release version of the application when the trace was created
	Release *string `json:"release,omitempty" url:"release,omitempty"`
	// The version of the trace
	Version *string `json:"version,omitempty" url:"version,omitempty"`
	// The user identifier associated with the trace
	UserID *string `json:"userId,omitempty" url:"userId,omitempty"`
	// The metadata associated with the trace. Can be any JSON.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The tags associated with the trace.
	Tags []string `json:"tags" url:"tags"`
	// Public traces are accessible via url without login
	Public bool `json:"public" url:"public"`
	// The environment from which this trace originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment string `json:"environment" url:"environment"`
	// Path of trace in Langfuse UI
	HTMLPath string `json:"htmlPath" url:"htmlPath"`
	// Latency of trace in seconds
	Latency *float64 `json:"latency,omitempty" url:"latency,omitempty"`
	// Cost of trace in USD
	TotalCost *float64 `json:"totalCost,omitempty" url:"totalCost,omitempty"`
	// List of observation ids
	Observations []string `json:"observations,omitempty" url:"observations,omitempty"`
	// List of score ids
	Scores []string `json:"scores,omitempty" url:"scores,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TraceWithDetails) GetID() string {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TraceWithDetails) GetTimestamp() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.Timestamp
}

func (t *TraceWithDetails) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TraceWithDetails) GetInput() interface{} {
	if t == nil {
		return nil
	}
	return t.Input
}

func (t *TraceWithDetails) GetOutput() interface{} {
	if t == nil {
		return nil
	}
	return t.Output
}

func (t *TraceWithDetails) GetSessionID() *string {
	if t == nil {
		return nil
	}
	return t.SessionID
}

func (t *TraceWithDetails) GetRelease() *string {
	if t == nil {
		return nil
	}
	return t.Release
}

func (t *TraceWithDetails) GetVersion() *string {
	if t == nil {
		return nil
	}
	return t.Version
}

func (t *TraceWithDetails) GetUserID() *string {
	if t == nil {
		return nil
	}
	return t.UserID
}

func (t *TraceWithDetails) GetMetadata() interface{} {
	if t == nil {
		return nil
	}
	return t.Metadata
}

func (t *TraceWithDetails) GetTags() []string {
	if t == nil {
		return nil
	}
	return t.Tags
}

func (t *TraceWithDetails) GetPublic() bool {
	if t == nil {
		return false
	}
	return t.Public
}

func (t *TraceWithDetails) GetEnvironment() string {
	if t == nil {
		return ""
	}
	return t.Environment
}

func (t *TraceWithDetails) GetHTMLPath() string {
	if t == nil {
		return ""
	}
	return t.HTMLPath
}

func (t *TraceWithDetails) GetLatency() *float64 {
	if t == nil {
		return nil
	}
	return t.Latency
}

func (t *TraceWithDetails) GetTotalCost() *float64 {
	if t == nil {
		return nil
	}
	return t.TotalCost
}

func (t *TraceWithDetails) GetObservations() []string {
	if t == nil {
		return nil
	}
	return t.Observations
}

func (t *TraceWithDetails) GetScores() []string {
	if t == nil {
		return nil
	}
	return t.Scores
}

func (t *TraceWithDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TraceWithDetails) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetID(id string) {
	t.ID = id
	t.require(traceWithDetailsFieldID)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetTimestamp(timestamp time.Time) {
	t.Timestamp = timestamp
	t.require(traceWithDetailsFieldTimestamp)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetName(name *string) {
	t.Name = name
	t.require(traceWithDetailsFieldName)
}

// SetInput sets the Input field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetInput(input interface{}) {
	t.Input = input
	t.require(traceWithDetailsFieldInput)
}

// SetOutput sets the Output field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetOutput(output interface{}) {
	t.Output = output
	t.require(traceWithDetailsFieldOutput)
}

// SetSessionID sets the SessionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetSessionID(sessionID *string) {
	t.SessionID = sessionID
	t.require(traceWithDetailsFieldSessionID)
}

// SetRelease sets the Release field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetRelease(release *string) {
	t.Release = release
	t.require(traceWithDetailsFieldRelease)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetVersion(version *string) {
	t.Version = version
	t.require(traceWithDetailsFieldVersion)
}

// SetUserID sets the UserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetUserID(userID *string) {
	t.UserID = userID
	t.require(traceWithDetailsFieldUserID)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetMetadata(metadata interface{}) {
	t.Metadata = metadata
	t.require(traceWithDetailsFieldMetadata)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetTags(tags []string) {
	t.Tags = tags
	t.require(traceWithDetailsFieldTags)
}

// SetPublic sets the Public field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetPublic(public bool) {
	t.Public = public
	t.require(traceWithDetailsFieldPublic)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetEnvironment(environment string) {
	t.Environment = environment
	t.require(traceWithDetailsFieldEnvironment)
}

// SetHTMLPath sets the HTMLPath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetHTMLPath(htmlPath string) {
	t.HTMLPath = htmlPath
	t.require(traceWithDetailsFieldHTMLPath)
}

// SetLatency sets the Latency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetLatency(latency *float64) {
	t.Latency = latency
	t.require(traceWithDetailsFieldLatency)
}

// SetTotalCost sets the TotalCost field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetTotalCost(totalCost *float64) {
	t.TotalCost = totalCost
	t.require(traceWithDetailsFieldTotalCost)
}

// SetObservations sets the Observations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetObservations(observations []string) {
	t.Observations = observations
	t.require(traceWithDetailsFieldObservations)
}

// SetScores sets the Scores field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithDetails) SetScores(scores []string) {
	t.Scores = scores
	t.require(traceWithDetailsFieldScores)
}

func (t *TraceWithDetails) UnmarshalJSON(data []byte) error {
	type embed TraceWithDetails
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TraceWithDetails(unmarshaler.embed)
	t.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TraceWithDetails) MarshalJSON() ([]byte, error) {
	type embed TraceWithDetails
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*t),
		Timestamp: internal.NewDateTime(t.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TraceWithDetails) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	traceWithFullDetailsFieldID           = big.NewInt(1 << 0)
	traceWithFullDetailsFieldTimestamp    = big.NewInt(1 << 1)
	traceWithFullDetailsFieldName         = big.NewInt(1 << 2)
	traceWithFullDetailsFieldInput        = big.NewInt(1 << 3)
	traceWithFullDetailsFieldOutput       = big.NewInt(1 << 4)
	traceWithFullDetailsFieldSessionID    = big.NewInt(1 << 5)
	traceWithFullDetailsFieldRelease      = big.NewInt(1 << 6)
	traceWithFullDetailsFieldVersion      = big.NewInt(1 << 7)
	traceWithFullDetailsFieldUserID       = big.NewInt(1 << 8)
	traceWithFullDetailsFieldMetadata     = big.NewInt(1 << 9)
	traceWithFullDetailsFieldTags         = big.NewInt(1 << 10)
	traceWithFullDetailsFieldPublic       = big.NewInt(1 << 11)
	traceWithFullDetailsFieldEnvironment  = big.NewInt(1 << 12)
	traceWithFullDetailsFieldHTMLPath     = big.NewInt(1 << 13)
	traceWithFullDetailsFieldLatency      = big.NewInt(1 << 14)
	traceWithFullDetailsFieldTotalCost    = big.NewInt(1 << 15)
	traceWithFullDetailsFieldObservations = big.NewInt(1 << 16)
	traceWithFullDetailsFieldScores       = big.NewInt(1 << 17)
)

type TraceWithFullDetails struct {
	// The unique identifier of a trace
	ID string `json:"id" url:"id"`
	// The timestamp when the trace was created
	Timestamp time.Time `json:"timestamp" url:"timestamp"`
	// The name of the trace
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The input data of the trace. Can be any JSON.
	Input interface{} `json:"input,omitempty" url:"input,omitempty"`
	// The output data of the trace. Can be any JSON.
	Output interface{} `json:"output,omitempty" url:"output,omitempty"`
	// The session identifier associated with the trace
	SessionID *string `json:"sessionId,omitempty" url:"sessionId,omitempty"`
	// The release version of the application when the trace was created
	Release *string `json:"release,omitempty" url:"release,omitempty"`
	// The version of the trace
	Version *string `json:"version,omitempty" url:"version,omitempty"`
	// The user identifier associated with the trace
	UserID *string `json:"userId,omitempty" url:"userId,omitempty"`
	// The metadata associated with the trace. Can be any JSON.
	Metadata interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The tags associated with the trace.
	Tags []string `json:"tags" url:"tags"`
	// Public traces are accessible via url without login
	Public bool `json:"public" url:"public"`
	// The environment from which this trace originated. Can be any lowercase alphanumeric string with hyphens and underscores that does not start with 'langfuse'.
	Environment string `json:"environment" url:"environment"`
	// Path of trace in Langfuse UI
	HTMLPath string `json:"htmlPath" url:"htmlPath"`
	// Latency of trace in seconds
	Latency *float64 `json:"latency,omitempty" url:"latency,omitempty"`
	// Cost of trace in USD
	TotalCost *float64 `json:"totalCost,omitempty" url:"totalCost,omitempty"`
	// List of observations
	Observations []*ObservationsView `json:"observations" url:"observations"`
	// List of scores
	Scores []*ScoreV1 `json:"scores" url:"scores"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TraceWithFullDetails) GetID() string {
	if t == nil {
		return ""
	}
	return t.ID
}

func (t *TraceWithFullDetails) GetTimestamp() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.Timestamp
}

func (t *TraceWithFullDetails) GetName() *string {
	if t == nil {
		return nil
	}
	return t.Name
}

func (t *TraceWithFullDetails) GetInput() interface{} {
	if t == nil {
		return nil
	}
	return t.Input
}

func (t *TraceWithFullDetails) GetOutput() interface{} {
	if t == nil {
		return nil
	}
	return t.Output
}

func (t *TraceWithFullDetails) GetSessionID() *string {
	if t == nil {
		return nil
	}
	return t.SessionID
}

func (t *TraceWithFullDetails) GetRelease() *string {
	if t == nil {
		return nil
	}
	return t.Release
}

func (t *TraceWithFullDetails) GetVersion() *string {
	if t == nil {
		return nil
	}
	return t.Version
}

func (t *TraceWithFullDetails) GetUserID() *string {
	if t == nil {
		return nil
	}
	return t.UserID
}

func (t *TraceWithFullDetails) GetMetadata() interface{} {
	if t == nil {
		return nil
	}
	return t.Metadata
}

func (t *TraceWithFullDetails) GetTags() []string {
	if t == nil {
		return nil
	}
	return t.Tags
}

func (t *TraceWithFullDetails) GetPublic() bool {
	if t == nil {
		return false
	}
	return t.Public
}

func (t *TraceWithFullDetails) GetEnvironment() string {
	if t == nil {
		return ""
	}
	return t.Environment
}

func (t *TraceWithFullDetails) GetHTMLPath() string {
	if t == nil {
		return ""
	}
	return t.HTMLPath
}

func (t *TraceWithFullDetails) GetLatency() *float64 {
	if t == nil {
		return nil
	}
	return t.Latency
}

func (t *TraceWithFullDetails) GetTotalCost() *float64 {
	if t == nil {
		return nil
	}
	return t.TotalCost
}

func (t *TraceWithFullDetails) GetObservations() []*ObservationsView {
	if t == nil {
		return nil
	}
	return t.Observations
}

func (t *TraceWithFullDetails) GetScores() []*ScoreV1 {
	if t == nil {
		return nil
	}
	return t.Scores
}

func (t *TraceWithFullDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TraceWithFullDetails) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetID(id string) {
	t.ID = id
	t.require(traceWithFullDetailsFieldID)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetTimestamp(timestamp time.Time) {
	t.Timestamp = timestamp
	t.require(traceWithFullDetailsFieldTimestamp)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetName(name *string) {
	t.Name = name
	t.require(traceWithFullDetailsFieldName)
}

// SetInput sets the Input field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetInput(input interface{}) {
	t.Input = input
	t.require(traceWithFullDetailsFieldInput)
}

// SetOutput sets the Output field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetOutput(output interface{}) {
	t.Output = output
	t.require(traceWithFullDetailsFieldOutput)
}

// SetSessionID sets the SessionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetSessionID(sessionID *string) {
	t.SessionID = sessionID
	t.require(traceWithFullDetailsFieldSessionID)
}

// SetRelease sets the Release field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetRelease(release *string) {
	t.Release = release
	t.require(traceWithFullDetailsFieldRelease)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetVersion(version *string) {
	t.Version = version
	t.require(traceWithFullDetailsFieldVersion)
}

// SetUserID sets the UserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetUserID(userID *string) {
	t.UserID = userID
	t.require(traceWithFullDetailsFieldUserID)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetMetadata(metadata interface{}) {
	t.Metadata = metadata
	t.require(traceWithFullDetailsFieldMetadata)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetTags(tags []string) {
	t.Tags = tags
	t.require(traceWithFullDetailsFieldTags)
}

// SetPublic sets the Public field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetPublic(public bool) {
	t.Public = public
	t.require(traceWithFullDetailsFieldPublic)
}

// SetEnvironment sets the Environment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetEnvironment(environment string) {
	t.Environment = environment
	t.require(traceWithFullDetailsFieldEnvironment)
}

// SetHTMLPath sets the HTMLPath field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetHTMLPath(htmlPath string) {
	t.HTMLPath = htmlPath
	t.require(traceWithFullDetailsFieldHTMLPath)
}

// SetLatency sets the Latency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetLatency(latency *float64) {
	t.Latency = latency
	t.require(traceWithFullDetailsFieldLatency)
}

// SetTotalCost sets the TotalCost field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetTotalCost(totalCost *float64) {
	t.TotalCost = totalCost
	t.require(traceWithFullDetailsFieldTotalCost)
}

// SetObservations sets the Observations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetObservations(observations []*ObservationsView) {
	t.Observations = observations
	t.require(traceWithFullDetailsFieldObservations)
}

// SetScores sets the Scores field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TraceWithFullDetails) SetScores(scores []*ScoreV1) {
	t.Scores = scores
	t.require(traceWithFullDetailsFieldScores)
}

func (t *TraceWithFullDetails) UnmarshalJSON(data []byte) error {
	type embed TraceWithFullDetails
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TraceWithFullDetails(unmarshaler.embed)
	t.Timestamp = unmarshaler.Timestamp.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TraceWithFullDetails) MarshalJSON() ([]byte, error) {
	type embed TraceWithFullDetails
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp"`
	}{
		embed:     embed(*t),
		Timestamp: internal.NewDateTime(t.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TraceWithFullDetails) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	tracesFieldData = big.NewInt(1 << 0)
	tracesFieldMeta = big.NewInt(1 << 1)
)

type Traces struct {
	Data []*TraceWithDetails `json:"data" url:"data"`
	Meta *UtilsMetaResponse  `json:"meta" url:"meta"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Traces) GetData() []*TraceWithDetails {
	if t == nil {
		return nil
	}
	return t.Data
}

func (t *Traces) GetMeta() *UtilsMetaResponse {
	if t == nil {
		return nil
	}
	return t.Meta
}

func (t *Traces) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Traces) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Traces) SetData(data []*TraceWithDetails) {
	t.Data = data
	t.require(tracesFieldData)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *Traces) SetMeta(meta *UtilsMetaResponse) {
	t.Meta = meta
	t.require(tracesFieldMeta)
}

func (t *Traces) UnmarshalJSON(data []byte) error {
	type unmarshaler Traces
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Traces(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Traces) MarshalJSON() ([]byte, error) {
	type embed Traces
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *Traces) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}
