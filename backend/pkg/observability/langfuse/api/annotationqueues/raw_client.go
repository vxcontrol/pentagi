// Code generated by Fern. DO NOT EDIT.

package annotationqueues

import (
    internal "pentagi/pkg/observability/langfuse/api/internal"
    core "pentagi/pkg/observability/langfuse/api/core"
    context "context"
    api "pentagi/pkg/observability/langfuse/api"
    option "pentagi/pkg/observability/langfuse/api/option"
    http "net/http"
)


type RawClient struct {
    baseURL string
    caller *internal.Caller
    options *core.RequestOptions
}

func NewRawClient(options *core.RequestOptions) *RawClient {
    return &RawClient{
        options: options,
        baseURL: options.BaseURL,
        caller: internal.NewCaller(
            &internal.CallerParams{
                Client: options.HTTPClient,
                MaxAttempts: options.MaxAttempts,
            },
        ),
    }
}

func (r *RawClient) Listqueues(
    ctx context.Context,
    request *api.AnnotationQueuesListQueuesRequest,
    opts ...option.RequestOption,
) (*core.Response[*api.PaginatedAnnotationQueues], error){
    options := core.NewRequestOptions(opts...)
    baseURL := internal.ResolveBaseURL(
        options.BaseURL,
        r.baseURL,
        "",
    )
    endpointURL := baseURL + "/api/public/annotation-queues"
    queryParams, err := internal.QueryValues(request)
    if err != nil {
        return nil, err
    }
    if len(queryParams) > 0 {
        endpointURL += "?" + queryParams.Encode()
    }
    headers := internal.MergeHeaders(
        r.options.ToHeader(),
        options.ToHeader(),
    )
    var response *api.PaginatedAnnotationQueues
    raw, err := r.caller.Call(
        ctx,
        &internal.CallParams{
            URL: endpointURL,
            Method: http.MethodGet,
            Headers: headers,
            MaxAttempts: options.MaxAttempts,
            BodyProperties: options.BodyProperties,
            QueryParameters: options.QueryParameters,
            Client: options.HTTPClient,
            Response: &response,
            ErrorDecoder: internal.NewErrorDecoder(api.ErrorCodes),
        },
    )
    if err != nil {
        return nil, err
    }
    return &core.Response[*api.PaginatedAnnotationQueues]{
        StatusCode: raw.StatusCode,
        Header: raw.Header,
        Body: response,
    }, nil
}

func (r *RawClient) Createqueue(
    ctx context.Context,
    request *api.CreateAnnotationQueueRequest,
    opts ...option.RequestOption,
) (*core.Response[*api.AnnotationQueue], error){
    options := core.NewRequestOptions(opts...)
    baseURL := internal.ResolveBaseURL(
        options.BaseURL,
        r.baseURL,
        "",
    )
    endpointURL := baseURL + "/api/public/annotation-queues"
    headers := internal.MergeHeaders(
        r.options.ToHeader(),
        options.ToHeader(),
    )
    headers.Add("Content-Type", "application/json")
    var response *api.AnnotationQueue
    raw, err := r.caller.Call(
        ctx,
        &internal.CallParams{
            URL: endpointURL,
            Method: http.MethodPost,
            Headers: headers,
            MaxAttempts: options.MaxAttempts,
            BodyProperties: options.BodyProperties,
            QueryParameters: options.QueryParameters,
            Client: options.HTTPClient,
            Request: request,
            Response: &response,
            ErrorDecoder: internal.NewErrorDecoder(api.ErrorCodes),
        },
    )
    if err != nil {
        return nil, err
    }
    return &core.Response[*api.AnnotationQueue]{
        StatusCode: raw.StatusCode,
        Header: raw.Header,
        Body: response,
    }, nil
}

func (r *RawClient) Getqueue(
    ctx context.Context,
    request *api.AnnotationQueuesGetQueueRequest,
    opts ...option.RequestOption,
) (*core.Response[*api.AnnotationQueue], error){
    options := core.NewRequestOptions(opts...)
    baseURL := internal.ResolveBaseURL(
        options.BaseURL,
        r.baseURL,
        "",
    )
    endpointURL := internal.EncodeURL(
        baseURL + "/api/public/annotation-queues/%v",
        request.QueueID,
    )
    headers := internal.MergeHeaders(
        r.options.ToHeader(),
        options.ToHeader(),
    )
    var response *api.AnnotationQueue
    raw, err := r.caller.Call(
        ctx,
        &internal.CallParams{
            URL: endpointURL,
            Method: http.MethodGet,
            Headers: headers,
            MaxAttempts: options.MaxAttempts,
            BodyProperties: options.BodyProperties,
            QueryParameters: options.QueryParameters,
            Client: options.HTTPClient,
            Response: &response,
            ErrorDecoder: internal.NewErrorDecoder(api.ErrorCodes),
        },
    )
    if err != nil {
        return nil, err
    }
    return &core.Response[*api.AnnotationQueue]{
        StatusCode: raw.StatusCode,
        Header: raw.Header,
        Body: response,
    }, nil
}

func (r *RawClient) Listqueueitems(
    ctx context.Context,
    request *api.AnnotationQueuesListQueueItemsRequest,
    opts ...option.RequestOption,
) (*core.Response[*api.PaginatedAnnotationQueueItems], error){
    options := core.NewRequestOptions(opts...)
    baseURL := internal.ResolveBaseURL(
        options.BaseURL,
        r.baseURL,
        "",
    )
    endpointURL := internal.EncodeURL(
        baseURL + "/api/public/annotation-queues/%v/items",
        request.QueueID,
    )
    queryParams, err := internal.QueryValues(request)
    if err != nil {
        return nil, err
    }
    if len(queryParams) > 0 {
        endpointURL += "?" + queryParams.Encode()
    }
    headers := internal.MergeHeaders(
        r.options.ToHeader(),
        options.ToHeader(),
    )
    var response *api.PaginatedAnnotationQueueItems
    raw, err := r.caller.Call(
        ctx,
        &internal.CallParams{
            URL: endpointURL,
            Method: http.MethodGet,
            Headers: headers,
            MaxAttempts: options.MaxAttempts,
            BodyProperties: options.BodyProperties,
            QueryParameters: options.QueryParameters,
            Client: options.HTTPClient,
            Response: &response,
            ErrorDecoder: internal.NewErrorDecoder(api.ErrorCodes),
        },
    )
    if err != nil {
        return nil, err
    }
    return &core.Response[*api.PaginatedAnnotationQueueItems]{
        StatusCode: raw.StatusCode,
        Header: raw.Header,
        Body: response,
    }, nil
}

func (r *RawClient) Createqueueitem(
    ctx context.Context,
    request *api.CreateAnnotationQueueItemRequest,
    opts ...option.RequestOption,
) (*core.Response[*api.AnnotationQueueItem], error){
    options := core.NewRequestOptions(opts...)
    baseURL := internal.ResolveBaseURL(
        options.BaseURL,
        r.baseURL,
        "",
    )
    endpointURL := internal.EncodeURL(
        baseURL + "/api/public/annotation-queues/%v/items",
        request.QueueID,
    )
    headers := internal.MergeHeaders(
        r.options.ToHeader(),
        options.ToHeader(),
    )
    headers.Add("Content-Type", "application/json")
    var response *api.AnnotationQueueItem
    raw, err := r.caller.Call(
        ctx,
        &internal.CallParams{
            URL: endpointURL,
            Method: http.MethodPost,
            Headers: headers,
            MaxAttempts: options.MaxAttempts,
            BodyProperties: options.BodyProperties,
            QueryParameters: options.QueryParameters,
            Client: options.HTTPClient,
            Request: request,
            Response: &response,
            ErrorDecoder: internal.NewErrorDecoder(api.ErrorCodes),
        },
    )
    if err != nil {
        return nil, err
    }
    return &core.Response[*api.AnnotationQueueItem]{
        StatusCode: raw.StatusCode,
        Header: raw.Header,
        Body: response,
    }, nil
}

func (r *RawClient) Getqueueitem(
    ctx context.Context,
    request *api.AnnotationQueuesGetQueueItemRequest,
    opts ...option.RequestOption,
) (*core.Response[*api.AnnotationQueueItem], error){
    options := core.NewRequestOptions(opts...)
    baseURL := internal.ResolveBaseURL(
        options.BaseURL,
        r.baseURL,
        "",
    )
    endpointURL := internal.EncodeURL(
        baseURL + "/api/public/annotation-queues/%v/items/%v",
        request.QueueID,
        request.ItemID,
    )
    headers := internal.MergeHeaders(
        r.options.ToHeader(),
        options.ToHeader(),
    )
    var response *api.AnnotationQueueItem
    raw, err := r.caller.Call(
        ctx,
        &internal.CallParams{
            URL: endpointURL,
            Method: http.MethodGet,
            Headers: headers,
            MaxAttempts: options.MaxAttempts,
            BodyProperties: options.BodyProperties,
            QueryParameters: options.QueryParameters,
            Client: options.HTTPClient,
            Response: &response,
            ErrorDecoder: internal.NewErrorDecoder(api.ErrorCodes),
        },
    )
    if err != nil {
        return nil, err
    }
    return &core.Response[*api.AnnotationQueueItem]{
        StatusCode: raw.StatusCode,
        Header: raw.Header,
        Body: response,
    }, nil
}

func (r *RawClient) Deletequeueitem(
    ctx context.Context,
    request *api.AnnotationQueuesDeleteQueueItemRequest,
    opts ...option.RequestOption,
) (*core.Response[*api.DeleteAnnotationQueueItemResponse], error){
    options := core.NewRequestOptions(opts...)
    baseURL := internal.ResolveBaseURL(
        options.BaseURL,
        r.baseURL,
        "",
    )
    endpointURL := internal.EncodeURL(
        baseURL + "/api/public/annotation-queues/%v/items/%v",
        request.QueueID,
        request.ItemID,
    )
    headers := internal.MergeHeaders(
        r.options.ToHeader(),
        options.ToHeader(),
    )
    var response *api.DeleteAnnotationQueueItemResponse
    raw, err := r.caller.Call(
        ctx,
        &internal.CallParams{
            URL: endpointURL,
            Method: http.MethodDelete,
            Headers: headers,
            MaxAttempts: options.MaxAttempts,
            BodyProperties: options.BodyProperties,
            QueryParameters: options.QueryParameters,
            Client: options.HTTPClient,
            Response: &response,
            ErrorDecoder: internal.NewErrorDecoder(api.ErrorCodes),
        },
    )
    if err != nil {
        return nil, err
    }
    return &core.Response[*api.DeleteAnnotationQueueItemResponse]{
        StatusCode: raw.StatusCode,
        Header: raw.Header,
        Body: response,
    }, nil
}

func (r *RawClient) Updatequeueitem(
    ctx context.Context,
    request *api.UpdateAnnotationQueueItemRequest,
    opts ...option.RequestOption,
) (*core.Response[*api.AnnotationQueueItem], error){
    options := core.NewRequestOptions(opts...)
    baseURL := internal.ResolveBaseURL(
        options.BaseURL,
        r.baseURL,
        "",
    )
    endpointURL := internal.EncodeURL(
        baseURL + "/api/public/annotation-queues/%v/items/%v",
        request.QueueID,
        request.ItemID,
    )
    headers := internal.MergeHeaders(
        r.options.ToHeader(),
        options.ToHeader(),
    )
    headers.Add("Content-Type", "application/json")
    var response *api.AnnotationQueueItem
    raw, err := r.caller.Call(
        ctx,
        &internal.CallParams{
            URL: endpointURL,
            Method: http.MethodPatch,
            Headers: headers,
            MaxAttempts: options.MaxAttempts,
            BodyProperties: options.BodyProperties,
            QueryParameters: options.QueryParameters,
            Client: options.HTTPClient,
            Request: request,
            Response: &response,
            ErrorDecoder: internal.NewErrorDecoder(api.ErrorCodes),
        },
    )
    if err != nil {
        return nil, err
    }
    return &core.Response[*api.AnnotationQueueItem]{
        StatusCode: raw.StatusCode,
        Header: raw.Header,
        Body: response,
    }, nil
}

func (r *RawClient) Createqueueassignment(
    ctx context.Context,
    request *api.AnnotationQueuesCreateQueueAssignmentRequest,
    opts ...option.RequestOption,
) (*core.Response[*api.CreateAnnotationQueueAssignmentResponse], error){
    options := core.NewRequestOptions(opts...)
    baseURL := internal.ResolveBaseURL(
        options.BaseURL,
        r.baseURL,
        "",
    )
    endpointURL := internal.EncodeURL(
        baseURL + "/api/public/annotation-queues/%v/assignments",
        request.QueueID,
    )
    headers := internal.MergeHeaders(
        r.options.ToHeader(),
        options.ToHeader(),
    )
    headers.Add("Content-Type", "application/json")
    var response *api.CreateAnnotationQueueAssignmentResponse
    raw, err := r.caller.Call(
        ctx,
        &internal.CallParams{
            URL: endpointURL,
            Method: http.MethodPost,
            Headers: headers,
            MaxAttempts: options.MaxAttempts,
            BodyProperties: options.BodyProperties,
            QueryParameters: options.QueryParameters,
            Client: options.HTTPClient,
            Request: request,
            Response: &response,
            ErrorDecoder: internal.NewErrorDecoder(api.ErrorCodes),
        },
    )
    if err != nil {
        return nil, err
    }
    return &core.Response[*api.CreateAnnotationQueueAssignmentResponse]{
        StatusCode: raw.StatusCode,
        Header: raw.Header,
        Body: response,
    }, nil
}

func (r *RawClient) Deletequeueassignment(
    ctx context.Context,
    request *api.AnnotationQueuesDeleteQueueAssignmentRequest,
    opts ...option.RequestOption,
) (*core.Response[*api.DeleteAnnotationQueueAssignmentResponse], error){
    options := core.NewRequestOptions(opts...)
    baseURL := internal.ResolveBaseURL(
        options.BaseURL,
        r.baseURL,
        "",
    )
    endpointURL := internal.EncodeURL(
        baseURL + "/api/public/annotation-queues/%v/assignments",
        request.QueueID,
    )
    headers := internal.MergeHeaders(
        r.options.ToHeader(),
        options.ToHeader(),
    )
    headers.Add("Content-Type", "application/json")
    var response *api.DeleteAnnotationQueueAssignmentResponse
    raw, err := r.caller.Call(
        ctx,
        &internal.CallParams{
            URL: endpointURL,
            Method: http.MethodDelete,
            Headers: headers,
            MaxAttempts: options.MaxAttempts,
            BodyProperties: options.BodyProperties,
            QueryParameters: options.QueryParameters,
            Client: options.HTTPClient,
            Request: request,
            Response: &response,
            ErrorDecoder: internal.NewErrorDecoder(api.ErrorCodes),
        },
    )
    if err != nil {
        return nil, err
    }
    return &core.Response[*api.DeleteAnnotationQueueAssignmentResponse]{
        StatusCode: raw.StatusCode,
        Header: raw.Header,
        Body: response,
    }, nil
}

