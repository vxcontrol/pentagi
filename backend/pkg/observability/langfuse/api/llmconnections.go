// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "pentagi/pkg/observability/langfuse/api/internal"
	time "time"
)

var (
	llmConnectionsListRequestFieldPage  = big.NewInt(1 << 0)
	llmConnectionsListRequestFieldLimit = big.NewInt(1 << 1)
)

type LlmConnectionsListRequest struct {
	// page number, starts at 1
	Page *int `json:"-" url:"page,omitempty"`
	// limit of items per page
	Limit *int `json:"-" url:"limit,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *LlmConnectionsListRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnectionsListRequest) SetPage(page *int) {
	l.Page = page
	l.require(llmConnectionsListRequestFieldPage)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnectionsListRequest) SetLimit(limit *int) {
	l.Limit = limit
	l.require(llmConnectionsListRequestFieldLimit)
}

type LlmAdapter string

const (
	LlmAdapterAnthropic      LlmAdapter = "anthropic"
	LlmAdapterOpenai         LlmAdapter = "openai"
	LlmAdapterAzure          LlmAdapter = "azure"
	LlmAdapterBedrock        LlmAdapter = "bedrock"
	LlmAdapterGoogleVertexAi LlmAdapter = "google-vertex-ai"
	LlmAdapterGoogleAiStudio LlmAdapter = "google-ai-studio"
)

func NewLlmAdapterFromString(s string) (LlmAdapter, error) {
	switch s {
	case "anthropic":
		return LlmAdapterAnthropic, nil
	case "openai":
		return LlmAdapterOpenai, nil
	case "azure":
		return LlmAdapterAzure, nil
	case "bedrock":
		return LlmAdapterBedrock, nil
	case "google-vertex-ai":
		return LlmAdapterGoogleVertexAi, nil
	case "google-ai-studio":
		return LlmAdapterGoogleAiStudio, nil
	}
	var t LlmAdapter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LlmAdapter) Ptr() *LlmAdapter {
	return &l
}

// LLM API connection configuration (secrets excluded)
var (
	llmConnectionFieldID                = big.NewInt(1 << 0)
	llmConnectionFieldProvider          = big.NewInt(1 << 1)
	llmConnectionFieldAdapter           = big.NewInt(1 << 2)
	llmConnectionFieldDisplaySecretKey  = big.NewInt(1 << 3)
	llmConnectionFieldBaseURL           = big.NewInt(1 << 4)
	llmConnectionFieldCustomModels      = big.NewInt(1 << 5)
	llmConnectionFieldWithDefaultModels = big.NewInt(1 << 6)
	llmConnectionFieldExtraHeaderKeys   = big.NewInt(1 << 7)
	llmConnectionFieldConfig            = big.NewInt(1 << 8)
	llmConnectionFieldCreatedAt         = big.NewInt(1 << 9)
	llmConnectionFieldUpdatedAt         = big.NewInt(1 << 10)
)

type LlmConnection struct {
	ID string `json:"id" url:"id"`
	// Provider name (e.g., 'openai', 'my-gateway'). Must be unique in project, used for upserting.
	Provider string `json:"provider" url:"provider"`
	// The adapter used to interface with the LLM
	Adapter string `json:"adapter" url:"adapter"`
	// Masked version of the secret key for display purposes
	DisplaySecretKey string `json:"displaySecretKey" url:"displaySecretKey"`
	// Custom base URL for the LLM API
	BaseURL *string `json:"baseURL,omitempty" url:"baseURL,omitempty"`
	// List of custom model names available for this connection
	CustomModels []string `json:"customModels" url:"customModels"`
	// Whether to include default models for this adapter
	WithDefaultModels bool `json:"withDefaultModels" url:"withDefaultModels"`
	// Keys of extra headers sent with requests (values excluded for security)
	ExtraHeaderKeys []string `json:"extraHeaderKeys" url:"extraHeaderKeys"`
	// Adapter-specific configuration. Required for Bedrock (`{"region":"us-east-1"}`), optional for VertexAI (`{"location":"us-central1"}`), not used by other adapters.
	Config    map[string]interface{} `json:"config,omitempty" url:"config,omitempty"`
	CreatedAt time.Time              `json:"createdAt" url:"createdAt"`
	UpdatedAt time.Time              `json:"updatedAt" url:"updatedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LlmConnection) GetID() string {
	if l == nil {
		return ""
	}
	return l.ID
}

func (l *LlmConnection) GetProvider() string {
	if l == nil {
		return ""
	}
	return l.Provider
}

func (l *LlmConnection) GetAdapter() string {
	if l == nil {
		return ""
	}
	return l.Adapter
}

func (l *LlmConnection) GetDisplaySecretKey() string {
	if l == nil {
		return ""
	}
	return l.DisplaySecretKey
}

func (l *LlmConnection) GetBaseURL() *string {
	if l == nil {
		return nil
	}
	return l.BaseURL
}

func (l *LlmConnection) GetCustomModels() []string {
	if l == nil {
		return nil
	}
	return l.CustomModels
}

func (l *LlmConnection) GetWithDefaultModels() bool {
	if l == nil {
		return false
	}
	return l.WithDefaultModels
}

func (l *LlmConnection) GetExtraHeaderKeys() []string {
	if l == nil {
		return nil
	}
	return l.ExtraHeaderKeys
}

func (l *LlmConnection) GetConfig() map[string]interface{} {
	if l == nil {
		return nil
	}
	return l.Config
}

func (l *LlmConnection) GetCreatedAt() time.Time {
	if l == nil {
		return time.Time{}
	}
	return l.CreatedAt
}

func (l *LlmConnection) GetUpdatedAt() time.Time {
	if l == nil {
		return time.Time{}
	}
	return l.UpdatedAt
}

func (l *LlmConnection) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LlmConnection) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnection) SetID(id string) {
	l.ID = id
	l.require(llmConnectionFieldID)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnection) SetProvider(provider string) {
	l.Provider = provider
	l.require(llmConnectionFieldProvider)
}

// SetAdapter sets the Adapter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnection) SetAdapter(adapter string) {
	l.Adapter = adapter
	l.require(llmConnectionFieldAdapter)
}

// SetDisplaySecretKey sets the DisplaySecretKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnection) SetDisplaySecretKey(displaySecretKey string) {
	l.DisplaySecretKey = displaySecretKey
	l.require(llmConnectionFieldDisplaySecretKey)
}

// SetBaseURL sets the BaseURL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnection) SetBaseURL(baseURL *string) {
	l.BaseURL = baseURL
	l.require(llmConnectionFieldBaseURL)
}

// SetCustomModels sets the CustomModels field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnection) SetCustomModels(customModels []string) {
	l.CustomModels = customModels
	l.require(llmConnectionFieldCustomModels)
}

// SetWithDefaultModels sets the WithDefaultModels field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnection) SetWithDefaultModels(withDefaultModels bool) {
	l.WithDefaultModels = withDefaultModels
	l.require(llmConnectionFieldWithDefaultModels)
}

// SetExtraHeaderKeys sets the ExtraHeaderKeys field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnection) SetExtraHeaderKeys(extraHeaderKeys []string) {
	l.ExtraHeaderKeys = extraHeaderKeys
	l.require(llmConnectionFieldExtraHeaderKeys)
}

// SetConfig sets the Config field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnection) SetConfig(config map[string]interface{}) {
	l.Config = config
	l.require(llmConnectionFieldConfig)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnection) SetCreatedAt(createdAt time.Time) {
	l.CreatedAt = createdAt
	l.require(llmConnectionFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LlmConnection) SetUpdatedAt(updatedAt time.Time) {
	l.UpdatedAt = updatedAt
	l.require(llmConnectionFieldUpdatedAt)
}

func (l *LlmConnection) UnmarshalJSON(data []byte) error {
	type embed LlmConnection
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LlmConnection(unmarshaler.embed)
	l.CreatedAt = unmarshaler.CreatedAt.Time()
	l.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LlmConnection) MarshalJSON() ([]byte, error) {
	type embed LlmConnection
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*l),
		CreatedAt: internal.NewDateTime(l.CreatedAt),
		UpdatedAt: internal.NewDateTime(l.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LlmConnection) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	paginatedLlmConnectionsFieldData = big.NewInt(1 << 0)
	paginatedLlmConnectionsFieldMeta = big.NewInt(1 << 1)
)

type PaginatedLlmConnections struct {
	Data []*LlmConnection   `json:"data" url:"data"`
	Meta *UtilsMetaResponse `json:"meta" url:"meta"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaginatedLlmConnections) GetData() []*LlmConnection {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaginatedLlmConnections) GetMeta() *UtilsMetaResponse {
	if p == nil {
		return nil
	}
	return p.Meta
}

func (p *PaginatedLlmConnections) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedLlmConnections) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedLlmConnections) SetData(data []*LlmConnection) {
	p.Data = data
	p.require(paginatedLlmConnectionsFieldData)
}

// SetMeta sets the Meta field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PaginatedLlmConnections) SetMeta(meta *UtilsMetaResponse) {
	p.Meta = meta
	p.require(paginatedLlmConnectionsFieldMeta)
}

func (p *PaginatedLlmConnections) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedLlmConnections
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedLlmConnections(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedLlmConnections) MarshalJSON() ([]byte, error) {
	type embed PaginatedLlmConnections
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PaginatedLlmConnections) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	upsertLlmConnectionRequestFieldProvider          = big.NewInt(1 << 0)
	upsertLlmConnectionRequestFieldAdapter           = big.NewInt(1 << 1)
	upsertLlmConnectionRequestFieldSecretKey         = big.NewInt(1 << 2)
	upsertLlmConnectionRequestFieldBaseURL           = big.NewInt(1 << 3)
	upsertLlmConnectionRequestFieldCustomModels      = big.NewInt(1 << 4)
	upsertLlmConnectionRequestFieldWithDefaultModels = big.NewInt(1 << 5)
	upsertLlmConnectionRequestFieldExtraHeaders      = big.NewInt(1 << 6)
	upsertLlmConnectionRequestFieldConfig            = big.NewInt(1 << 7)
)

type UpsertLlmConnectionRequest struct {
	// Provider name (e.g., 'openai', 'my-gateway'). Must be unique in project, used for upserting.
	Provider string `json:"provider" url:"-"`
	// The adapter used to interface with the LLM
	Adapter LlmAdapter `json:"adapter" url:"-"`
	// Secret key for the LLM API.
	SecretKey string `json:"secretKey" url:"-"`
	// Custom base URL for the LLM API
	BaseURL *string `json:"baseURL,omitempty" url:"-"`
	// List of custom model names
	CustomModels []string `json:"customModels,omitempty" url:"-"`
	// Whether to include default models. Default is true.
	WithDefaultModels *bool `json:"withDefaultModels,omitempty" url:"-"`
	// Extra headers to send with requests
	ExtraHeaders map[string]*string `json:"extraHeaders,omitempty" url:"-"`
	// Adapter-specific configuration. Validation rules: - **Bedrock**: Required. Must be `{"region": "<aws-region>"}` (e.g., `{"region":"us-east-1"}`) - **VertexAI**: Optional. If provided, must be `{"location": "<gcp-location>"}` (e.g., `{"location":"us-central1"}`) - **Other adapters**: Not supported. Omit this field or set to null.
	Config map[string]interface{} `json:"config,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (u *UpsertLlmConnectionRequest) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetProvider sets the Provider field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpsertLlmConnectionRequest) SetProvider(provider string) {
	u.Provider = provider
	u.require(upsertLlmConnectionRequestFieldProvider)
}

// SetAdapter sets the Adapter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpsertLlmConnectionRequest) SetAdapter(adapter LlmAdapter) {
	u.Adapter = adapter
	u.require(upsertLlmConnectionRequestFieldAdapter)
}

// SetSecretKey sets the SecretKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpsertLlmConnectionRequest) SetSecretKey(secretKey string) {
	u.SecretKey = secretKey
	u.require(upsertLlmConnectionRequestFieldSecretKey)
}

// SetBaseURL sets the BaseURL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpsertLlmConnectionRequest) SetBaseURL(baseURL *string) {
	u.BaseURL = baseURL
	u.require(upsertLlmConnectionRequestFieldBaseURL)
}

// SetCustomModels sets the CustomModels field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpsertLlmConnectionRequest) SetCustomModels(customModels []string) {
	u.CustomModels = customModels
	u.require(upsertLlmConnectionRequestFieldCustomModels)
}

// SetWithDefaultModels sets the WithDefaultModels field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpsertLlmConnectionRequest) SetWithDefaultModels(withDefaultModels *bool) {
	u.WithDefaultModels = withDefaultModels
	u.require(upsertLlmConnectionRequestFieldWithDefaultModels)
}

// SetExtraHeaders sets the ExtraHeaders field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpsertLlmConnectionRequest) SetExtraHeaders(extraHeaders map[string]*string) {
	u.ExtraHeaders = extraHeaders
	u.require(upsertLlmConnectionRequestFieldExtraHeaders)
}

// SetConfig sets the Config field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpsertLlmConnectionRequest) SetConfig(config map[string]interface{}) {
	u.Config = config
	u.require(upsertLlmConnectionRequestFieldConfig)
}

func (u *UpsertLlmConnectionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertLlmConnectionRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*u = UpsertLlmConnectionRequest(body)
	return nil
}

func (u *UpsertLlmConnectionRequest) MarshalJSON() ([]byte, error) {
	type embed UpsertLlmConnectionRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}
