// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "pentagi/pkg/observability/langfuse/api/internal"
)

var (
	metricsMetricsRequestFieldQuery = big.NewInt(1 << 0)
)

type MetricsMetricsRequest struct {
	// JSON string containing the query parameters with the following structure:
	// ```json
	//
	//	{
	//	  "view": string,           // Required. One of "traces", "observations", "scores-numeric", "scores-categorical"
	//	  "dimensions": [           // Optional. Default: []
	//	    {
	//	      "field": string       // Field to group by, e.g. "name", "userId", "sessionId"
	//	    }
	//	  ],
	//	  "metrics": [              // Required. At least one metric must be provided
	//	    {
	//	      "measure": string,    // What to measure, e.g. "count", "latency", "value"
	//	      "aggregation": string // How to aggregate, e.g. "count", "sum", "avg", "p95", "histogram"
	//	    }
	//	  ],
	//	  "filters": [              // Optional. Default: []
	//	    {
	//	      "column": string,     // Column to filter on
	//	      "operator": string,   // Operator, e.g. "=", ">", "<", "contains"
	//	      "value": any,         // Value to compare against
	//	      "type": string,       // Data type, e.g. "string", "number", "stringObject"
	//	      "key": string         // Required only when filtering on metadata
	//	    }
	//	  ],
	//	  "timeDimension": {        // Optional. Default: null. If provided, results will be grouped by time
	//	    "granularity": string   // One of "minute", "hour", "day", "week", "month", "auto"
	//	  },
	//	  "fromTimestamp": string,  // Required. ISO datetime string for start of time range
	//	  "toTimestamp": string,    // Required. ISO datetime string for end of time range
	//	  "orderBy": [              // Optional. Default: null
	//	    {
	//	      "field": string,      // Field to order by
	//	      "direction": string   // "asc" or "desc"
	//	    }
	//	  ],
	//	  "config": {               // Optional. Query-specific configuration
	//	    "bins": number,         // Optional. Number of bins for histogram (1-100), default: 10
	//	    "row_limit": number     // Optional. Row limit for results (1-1000)
	//	  }
	//	}
	//
	// ```
	Query string `json:"-" url:"query"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (m *MetricsMetricsRequest) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetQuery sets the Query field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MetricsMetricsRequest) SetQuery(query string) {
	m.Query = query
	m.require(metricsMetricsRequestFieldQuery)
}

var (
	metricsResponseFieldData = big.NewInt(1 << 0)
)

type MetricsResponse struct {
	// The metrics data. Each item in the list contains the metric values and dimensions requested in the query.
	// Format varies based on the query parameters.
	// Histograms will return an array with [lower, upper, height] tuples.
	Data []map[string]interface{} `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetricsResponse) GetData() []map[string]interface{} {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MetricsResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetricsResponse) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MetricsResponse) SetData(data []map[string]interface{}) {
	m.Data = data
	m.require(metricsResponseFieldData)
}

func (m *MetricsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler MetricsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetricsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetricsResponse) MarshalJSON() ([]byte, error) {
	type embed MetricsResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MetricsResponse) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}
